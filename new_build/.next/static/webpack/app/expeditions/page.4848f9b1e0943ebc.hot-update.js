"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/expeditions/page",{

/***/ "(app-pages-browser)/./src/app/util/petHelper.js":
/*!***********************************!*\
  !*** ./src/app/util/petHelper.js ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helper.js */ \"(app-pages-browser)/./src/app/util/helper.js\");\n\nvar helper = {\n    EXP_DMG_MOD: .1,\n    EXP_TIME_MOD: .05,\n    SYNERGY_MOD_STEP: .25,\n    EXP_TOKEN_MOD: 0.05,\n    SOUL_CLOVER_STEP: 0.25,\n    calculatePetBaseDamage: function(pet1, defaultRank) {\n        const rankCount = defaultRank ? defaultRank : pet1 === null || pet1 === void 0 ? void 0 : pet1.Rank;\n        const result = (pet1 === null || pet1 === void 0 ? void 0 : pet1.BaseDungeonDamage) * (1.0 + rankCount * 0.05);\n        return Number(result);\n    },\n    calculateBestHours: function(group, hours, tokenModifiers, combo) {\n        let clover;\n        let residueToken = (tokenModifiers === null || tokenModifiers === void 0 ? void 0 : tokenModifiers.residueToken) ? tokenModifiers.residueToken : 0;\n        //contains clover and other                 contains active (special) bonuses\n        let pd_token_bonus = tokenModifiers.data.ExpeditionTokenBonuses * tokenModifiers.data.ExpeditionResourceBonuses;\n        if (!hours) {\n            hours = [\n                1,\n                2,\n                3,\n                4,\n                5,\n                6,\n                7,\n                8,\n                9,\n                10,\n                11,\n                12\n            ];\n        }\n        if (!clover) {\n            clover = (tokenModifiers === null || tokenModifiers === void 0 ? void 0 : tokenModifiers.clover) ? tokenModifiers.clover : 0;\n        }\n        if (!combo) {\n            combo = 1.0;\n        }\n        const overall = this.calculateGroupScore(group);\n        //includes pet token gain \n        const tokenHR = overall.tokenMult * pd_token_bonus * combo;\n        let best = {\n            hours: -1,\n            totalTokens: -1,\n            floored: -1,\n            effeciency: -1\n        };\n        let bestArr = [];\n        for(let i = 0; i < hours.length; i++){\n            let h = hours[i];\n            let totalTokens = tokenHR + 1 / 3600 * tokenHR; //assuming 1hr runs\n            let floored = Math.floor(totalTokens);\n            let effeciency = floored / totalTokens;\n            let wasted = totalTokens - floored;\n            let wastedHR = wasted / h;\n            let temp = {\n                wastedHR: wastedHR,\n                tokenHR: tokenHR + 1 / 3600 * tokenHR,\n                wasted: wasted,\n                hours: h,\n                totalTokens: totalTokens,\n                floored: floored,\n                effeciency: effeciency\n            };\n            bestArr.push(temp);\n        // if (effeciency > best.effeciency) {\n        //     bestArr = [];\n        //     best = { hours: h, totalTokens: totalTokens, floored: floored, effeciency: effeciency };\n        //     bestArr.push(best);\n        // }\n        // else if (effeciency === best.effeciency) {\n        //     best = { hours: h, totalTokens: totalTokens, floored: floored, effeciency: effeciency };\n        //     bestArr.push(best);\n        // }\n        }\n        // bestArr.sort((a, b) => { return a.wasted - b.wasted })\n        // bestArr.sort((a, b) => {\n        //     let a_waste = general_helper.roundThreeDecimal(a.wastedHR)\n        //     let b_waste = general_helper.roundThreeDecimal(b.wastedHR)\n        //     if (a_waste === b_waste) {\n        //         return a.hours - b.hours;\n        //     }\n        //     return a_waste - b_waste;\n        // })\n        return bestArr;\n    },\n    calculateGroupScore: function(group, defaultRank) {\n        let groupScore = 0;\n        let dmgCount = 0;\n        let timeCount = 0;\n        let synergyBonus = 0;\n        let baseGroupScore = 0;\n        let cardPowerCount = 0;\n        let expRewardCount = 0;\n        let rpRewardCount = 0;\n        let cardXpCount = 0;\n        let tokenRewardCount = 0;\n        let tokenMult = 0;\n        let tokenModif = 0;\n        const typeCounts = {};\n        let groupScoreMax = 0;\n        group.forEach((pet1)=>{\n            groupScore += this.calculatePetBaseDamage(pet1, defaultRank);\n            groupScoreMax += this.calculatePetBaseDamage(pet1, 0);\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1013)) {\n                dmgCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1010)) {\n                cardPowerCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1011)) {\n                expRewardCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1014)) {\n                cardXpCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1012)) {\n                timeCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1015)) {\n                rpRewardCount++;\n            }\n            if (pet1.BonusList.some((bonus)=>bonus.ID === 1016)) {\n                tokenRewardCount++;\n            }\n            // Count pet types\n            if (typeCounts[pet1.Type]) {\n                typeCounts[pet1.Type]++;\n            } else {\n                typeCounts[pet1.Type] = 1;\n            }\n            if (pet1.ID) synergyBonus += this.SYNERGY_MOD_STEP;\n        });\n        baseGroupScore = groupScore;\n        const [earthType, airType] = Object.values(typeCounts);\n        if (earthType > 0 && airType > 0) synergyBonus += this.SYNERGY_MOD_STEP;\n        if (earthType > 1 && airType > 1) synergyBonus += this.SYNERGY_MOD_STEP;\n        groupScore *= 1 + dmgCount * this.EXP_DMG_MOD;\n        groupScoreMax *= 1 + dmgCount * this.EXP_DMG_MOD;\n        groupScore *= 1 + timeCount * this.EXP_TIME_MOD;\n        groupScoreMax *= 1 + timeCount * this.EXP_TIME_MOD;\n        groupScore *= synergyBonus;\n        groupScoreMax *= synergyBonus;\n        tokenModif = tokenRewardCount * this.EXP_TOKEN_MOD;\n        tokenMult = synergyBonus + synergyBonus * tokenModif;\n        return {\n            groupScore,\n            baseGroupScore,\n            groupScoreMax,\n            dmgCount,\n            timeCount,\n            synergyBonus,\n            cardPowerCount,\n            expRewardCount,\n            cardXpCount,\n            rpRewardCount,\n            tokenRewardCount,\n            tokenModif,\n            tokenMult\n        };\n    },\n    getBestDamagePets: function(petsCollection, defaultRank, other) {\n        let finalCollection = {};\n        let bestDamagePets = JSON.parse(JSON.stringify(petsCollection));\n        //As required + miscellenaous pets are added, keep track of top 4 strongest -> to prevent adding non-special weak pets\n        //This really initially only stores required, exp dmg, exp time bonus pets\n        let strongestGnd = [];\n        let strongestAir = [];\n        const updateStrongest = (pet1)=>{\n            //Ground\n            if (pet1.Type === 1) {\n                //No pets yet, just add it\n                if (strongestGnd.length === 0) {\n                    strongestGnd.push(pet1);\n                } else if (strongestGnd.length === 1) {\n                    if (this.calculatePetBaseDamage(strongestGnd[0], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                        strongestGnd[1] = strongestGnd[0];\n                        strongestGnd[0] = pet1;\n                    } else {\n                        strongestGnd[1] = pet1;\n                    }\n                } else if (this.calculatePetBaseDamage(strongestGnd[0], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                    strongestGnd[1] = strongestGnd[0];\n                    strongestGnd[0] = pet1;\n                } else if (this.calculatePetBaseDamage(strongestGnd[1], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                    strongestGnd[1] = pet1;\n                }\n            } else if (pet1.Type === 2) {\n                //No pets yet, just add it\n                if (strongestAir.length === 0) {\n                    strongestAir.push(pet1);\n                } else if (strongestAir.length === 1) {\n                    if (this.calculatePetBaseDamage(strongestAir[0], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                        strongestAir[1] = strongestAir[0];\n                        strongestAir[0] = pet1;\n                    } else {\n                        strongestAir[1] = pet1;\n                    }\n                } else if (this.calculatePetBaseDamage(strongestAir[0], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                    strongestAir[1] = strongestAir[0];\n                    strongestAir[0] = pet1;\n                } else if (this.calculatePetBaseDamage(strongestAir[1], defaultRank) < this.calculatePetBaseDamage(pet1, defaultRank)) {\n                    strongestAir[1] = pet1;\n                }\n            }\n        };\n        let dmgOnlyPets = [];\n        let requiredPets = {};\n        let airDmgOnlyCount = 0;\n        let gndDmgOnlyCount = 0;\n        if (other) {\n            if (other.requiredPets) {\n                for(let i = 0; i < other.requiredPets.length; i++){\n                    requiredPets[other.requiredPets[i].ID] = other.requiredPets[i];\n                }\n            }\n        }\n        for(let i = 0; i < bestDamagePets.length; i++){\n            let cur = bestDamagePets[i];\n            let added = false;\n            for(let j = 0; j < cur.BonusList.length; j++){\n                let bonus = cur.BonusList[j];\n                //Add any required pets to the list\n                if (cur.ID in requiredPets) {\n                    finalCollection[cur.ID] = cur;\n                    added = true;\n                } else if (bonus.ID === 1013) {\n                    if (!finalCollection[cur.ID]) {\n                        finalCollection[cur.ID] = cur;\n                        added = true;\n                    }\n                }\n                //Dng time bonus\n                if (bonus.ID === 1012) {\n                    if (!finalCollection[cur.ID]) {\n                        finalCollection[cur.ID] = cur;\n                        added = true;\n                    }\n                }\n            }\n            if (!added) {\n                dmgOnlyPets.push(cur);\n                if (cur.Type === 1) {\n                    gndDmgOnlyCount++;\n                } else {\n                    airDmgOnlyCount++;\n                }\n            } else {\n                updateStrongest(cur);\n            }\n        }\n        const specialAir = strongestAir.length;\n        const specialGnd = strongestGnd.length;\n        let specialPets = strongestAir.concat(strongestGnd);\n        //Add all the special pets to the required list\n        for(let i = 0; i < specialPets; i++){\n            finalCollection[pet.ID] = specialPets[i];\n        }\n        //How many more pets of each type I need to find still (i.e. if I have a total of 1 air pets, then i need 3 ground)\n        let extraGnd = 2;\n        let extraAir = 2;\n        if (specialGnd + gndDmgOnlyCount < 2) {\n            extraAir += 2 - (specialGnd + gndDmgOnlyCount);\n        }\n        if (specialAir + airDmgOnlyCount < 2) {\n            extraGnd += 2 - (specialAir + airDmgOnlyCount);\n        }\n        let sortGnd = false;\n        let sortAir = false;\n        //Go over remaining pure dmg pets, and find the top 4 (preferable 2gnd and 2air to put in to consider together with special pets)\n        for(let i = 0; i < dmgOnlyPets.length; i++){\n            let pet1 = dmgOnlyPets[i];\n            let dmg = this.calculatePetBaseDamage(pet1, defaultRank);\n            if (pet1.Type === 1) {\n                if (strongestGnd.length < extraGnd) {\n                    strongestGnd.push(pet1);\n                    sortGnd = true;\n                } else {\n                    for(let j = 0; j < strongestGnd.length; j++){\n                        let innerPet = strongestGnd[j];\n                        let innerDmg = this.calculatePetBaseDamage(innerPet, defaultRank);\n                        if (dmg > innerDmg) {\n                            strongestGnd[j] = pet1;\n                            sortGnd = true;\n                            break;\n                        }\n                    }\n                }\n            } else {\n                if (strongestAir.length < extraAir) {\n                    strongestAir.push(pet1);\n                    sortAir = true;\n                } else {\n                    for(let j = 0; j < strongestAir.length; j++){\n                        let innerPet = strongestAir[j];\n                        let innerDmg = this.calculatePetBaseDamage(innerPet, defaultRank);\n                        if (dmg > innerDmg) {\n                            strongestAir[j] = pet1;\n                            sortAir = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            //Make sure to sort in reverse order!! because i replace the first pet I beat (which needs to be the weakest one)\n            if (sortGnd) {\n                sortGnd = false;\n                strongestGnd.sort((a, b)=>this.calculatePetBaseDamage(a, defaultRank) - this.calculatePetBaseDamage(b, defaultRank));\n            }\n            if (sortAir) {\n                sortAir = false;\n                strongestAir.sort((a, b)=>this.calculatePetBaseDamage(a, defaultRank) - this.calculatePetBaseDamage(b, defaultRank));\n            }\n        }\n        //Make the updated list and add it all in, duplicates will just overwrite themselves so its fine\n        specialPets = strongestAir.concat(strongestGnd);\n        //Add all the special pets to the required list\n        for(let i = 0; i < specialPets.length; i++){\n            finalCollection[specialPets[i].ID] = specialPets[i];\n        }\n        let finalPetsCollection = Object.values(finalCollection);\n        finalPetsCollection.sort((a, b)=>b.ID - a.ID);\n        return finalPetsCollection;\n    // //Sort remaining\n    // dmgOnlyPets.sort((a, b) => this.calculatePetBaseDamage(b, defaultRank) - this.calculatePetBaseDamage(a, defaultRank));\n    // let airTotal = 0;\n    // let groundTotal = 0;\n    // dmgOnlyPets.map((curr) => {\n    //     if (curr.Type === 1) groundTotal++;\n    //     if (curr.Type === 2) airTotal++;\n    // })\n    // let ground = 0;//type 1\n    // let air = 0; //type 2\n    // let counter = 0;\n    // if (groundTotal < 2) {\n    //     let ground = [];\n    //     groundTotal = 0;\n    //     dmgOnlyPets.map((cur) => {\n    //         if (cur.Type === 1) {\n    //             ground.push(cur);\n    //             finalCollection[cur.ID] = cur;\n    //             dmgOnlyPets = dmgOnlyPets.filter((current) => {\n    //                 return current.ID !== cur.ID\n    //             })\n    //         }\n    //     });\n    // }\n    // if (airTotal < 2) {\n    //     let air = [];\n    //     airTotal = 0;\n    //     dmgOnlyPets.map((cur) => {\n    //         if (cur.Type === 2) {\n    //             air.push(cur);\n    //             finalCollection[cur.ID] = cur;\n    //             dmgOnlyPets = dmgOnlyPets.filter((current) => {\n    //                 return current.ID !== cur.ID\n    //             })\n    //         }\n    //     });\n    // }\n    // for (let i = 0; i < dmgOnlyPets.length; i++) {\n    //     let cur = dmgOnlyPets[i];\n    //     if (ground < 2 && cur.Type === 1 || airTotal <= 0) {\n    //         //Check if we need to add current pet, or the strongestGnd are strong enough\n    //         if (strongestGnd.length > 0) {\n    //             let j = 0;\n    //             while (strongestGnd.length > 0 && j <= strongestGnd.length) {\n    //                 let stng = strongestGnd[j];\n    //                 if (stng) {\n    //                     if (this.calculatePetBaseDamage(stng, defaultRank) >= this.calculatePetBaseDamage(cur, defaultRank)) {\n    //                         strongestGnd.splice(j, 1);\n    //                         finalCollection[cur.ID] = cur;\n    //                         ground++;\n    //                         counter++;\n    //                         j--;\n    //                     }\n    //                 }\n    //                 j++;\n    //             }\n    //         }\n    //         //Potentially 2 strongest are better than current, so don't add it if we added the other 2, or if there are no air and counter less than 3\n    //         if (ground < 2 || (counter < 4 && airTotal <= 0)) {\n    //             finalCollection[cur.ID] = cur;\n    //             ground++;\n    //             counter++;\n    //             groundTotal--;\n    //         }\n    //     }\n    //     else if (air < 2 && cur.Type === 2 || groundTotal <= 0) {\n    //         //Check if we need to add current pet, or the strongestGnd are strong enough\n    //         if (strongestAir.length > 0) {\n    //             let j = 0;\n    //             while (strongestAir.length > 0 && j <= strongestAir.length) {\n    //                 let stng = strongestAir[j];\n    //                 if (stng) {\n    //                     if (this.calculatePetBaseDamage(stng, defaultRank) >= this.calculatePetBaseDamage(cur, defaultRank)) {\n    //                         strongestAir.splice(j, 1);\n    //                         finalCollection[cur.ID] = cur;\n    //                         air++;\n    //                         counter++;\n    //                         j--;\n    //                     }\n    //                 }\n    //                 j++;\n    //             }\n    //         }\n    //         //Potentially 2 strongest are better than current, so don't add it if we added the other 2, or if there are no air and counter less than 3\n    //         if (air < 2 || (counter < 4 && groundTotal <= 0)) {\n    //             finalCollection[cur.ID] = cur;\n    //             air++;\n    //             counter++\n    //             airTotal--;\n    //         }\n    //     }\n    //     if (counter > 3) break;\n    // }\n    // let finalPetsCollection = Object.values(finalCollection);\n    // finalPetsCollection.sort((a, b) => b.ID - a.ID);\n    // return finalPetsCollection;\n    },\n    calcBestDamageGroup: function(PETSCOLLECTION, defaultRank, numGroups, other) {\n        const k = 4; // Size of each group\n        numGroups = numGroups ? numGroups : 7;\n        numGroups = Number(numGroups);\n        const memo = {};\n        let failedFiltersObj = {};\n        let petsMap = {};\n        other = JSON.parse(JSON.stringify(other));\n        for(let i = 0; i < PETSCOLLECTION.length; i++){\n            petsMap[PETSCOLLECTION[i].ID] = JSON.parse(JSON.stringify(PETSCOLLECTION[i]));\n        }\n        let activeBonuses = other === null || other === void 0 ? void 0 : other.activeBonuses;\n        if (!activeBonuses) activeBonuses = [];\n        const memoizedGroupScore = (group)=>{\n            const key = group.ID;\n            if (!memo[key] || memo[key]) {\n                let res = this.calculateGroupScore(group.team, defaultRank);\n                let sum = res.tokenMult;\n                memo[key] = {\n                    token: sum,\n                    damage: res.groupScore,\n                    other: res\n                };\n            }\n            return memo[key];\n        };\n        let blackList = {};\n        let whitelist = {};\n        let whitelistRel = {};\n        let lockedPets = {};\n        let autoPets = {};\n        let psuedoGroups = [];\n        for(let i = 0; i < numGroups; i++){\n            psuedoGroups.push([]);\n        }\n        if (other === null || other === void 0 ? void 0 : other.petWhiteList) {\n            for(let i = 0; i < other.petWhiteList.length; i++){\n                let cur = other.petWhiteList[i];\n                if (cur.placement === \"blacklist\") {\n                    blackList[cur.id] = cur;\n                } else if (cur.placement === \"team\") {\n                    whitelist[cur.id] = cur;\n                    lockedPets[cur.id] = cur;\n                    psuedoGroups[cur.parameters.team].push(cur);\n                } else if (cur.placement === \"rel\") {\n                    whitelistRel[cur.id] = cur;\n                }\n            }\n            //Go over any `auto placements and slot them in in a pseudo manner\n            for(let i = 0; i < other.petWhiteList.length; i++){\n                let cur = other.petWhiteList[i];\n                if (cur.placement === \"auto\") {\n                    let bigsad = -1;\n                    for(let j = numGroups - 1; j >= 0; j--){\n                        let numGnd = 0;\n                        let numAir = 0;\n                        psuedoGroups[j].forEach((inner_pet)=>{\n                            if (inner_pet.pet.Type === 1) {\n                                numGnd++;\n                            }\n                            if (inner_pet.pet.Type === 2) {\n                                numAir++;\n                            }\n                        });\n                        if (cur.pet.Type === 1 && numGnd > 1) {\n                            continue;\n                        }\n                        if (cur.pet.Type === 2 && numAir > 1) {\n                            continue;\n                        }\n                        if (psuedoGroups[j].length < k) {\n                            cur.auto = true;\n                            cur.parameters.team = j;\n                            cur.placement = \"team\";\n                            whitelist[cur.id] = cur;\n                            psuedoGroups[j].push(cur);\n                            autoPets[cur.id] = cur;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        const getCombinationsInner = (array, k, bonusList)=>{\n            // let temp = [];\n            let best = -1;\n            //confirm there is enough gnd/air for perfect synergy\n            let airTemp = 0;\n            let groundTemp = 0;\n            array.forEach((item)=>{\n                if (item.Type === 1) groundTemp++;\n                else airTemp++;\n            });\n            let bad_synergy_allowed = true;\n            if (airTemp > 1 && groundTemp > 1) {\n                bad_synergy_allowed = false;\n            }\n            //Number of air/gnd pets that are manually placed -> default allow bad synergy\n            let requiredAir = {};\n            let requiredGnd = {};\n            //Check num air and num ground relative pets from bonus\n            let relAirTotalMap = {};\n            let relGndTotalMap = {};\n            for(let i = 0; i < bonusList.length; i++){\n                let bonus = bonusList[i];\n                if (bonus.placement === \"team\") {\n                    if (!bonus.parameters.fake) {\n                        if (bonus.pet.Type === 1 && !requiredGnd[bonus.pet.ID]) {\n                            requiredGnd[bonus.pet.ID] = true;\n                        } else if (!requiredGnd[bonus.pet.ID]) {\n                            requiredAir[bonus.pet.ID] = true;\n                        } else {\n                            let bigsad = -1;\n                        }\n                    } else {\n                        if (bonus.pet.Type === 2 && !relAirTotalMap[bonus.pet.ID]) {\n                            relAirTotalMap[bonus.pet.ID] = true;\n                        } else if (!relGndTotalMap[bonus.pet.ID]) {\n                            relGndTotalMap[bonus.pet.ID] = true;\n                        }\n                    }\n                }\n            }\n            const f = (start, prevCombination)=>{\n                if (prevCombination.length > 0) {\n                    let validTeam = true;\n                    let fakeRel = 0;\n                    let exact = 0;\n                    const maxPets = 4;\n                    //Check how many pets of each type are the correct rel ones\n                    let currAir = 0;\n                    let currGnd = 0;\n                    //absolute number of each type of pet\n                    let totalGnd = 0;\n                    let totalAir = 0;\n                    for(let j = 0; j < prevCombination.length; j++){\n                        let tempy = prevCombination[j];\n                        if (tempy.Type === 1) {\n                            totalGnd++;\n                        } else {\n                            totalAir++;\n                        }\n                        if (tempy.Type === 1 && relGndTotalMap[tempy.ID]) {\n                            currGnd++;\n                        } else if (relAirTotalMap[tempy.ID]) {\n                            currAir++;\n                        }\n                    }\n                    let reqAir = Object.entries(requiredAir).length;\n                    let reqGnd = Object.entries(requiredGnd).length;\n                    let relAirTotal = Object.entries(relAirTotalMap).length;\n                    let relGndTotal = Object.entries(relGndTotalMap).length;\n                    //Determine how many more `rel` of gnd/fly type are allowed based on how many hard (placement=group) there are\n                    let airLimit = 2 > reqAir ? 2 - reqAir : 0;\n                    let gndLimit = 2 > reqGnd ? 2 - reqGnd : 0;\n                    let maxRel = 0;\n                    //I can have a max of 2 air or 2 ground\n                    // if i have any required air, number of relative air allowed is 2 - required\n                    // if num relative air > 0 I need to make sure i have a an air, but less then the number above\n                    //If there are any relative air pets required\n                    if (relAirTotal > 0) {\n                        let checkNum = relAirTotal < airLimit ? relAirTotal : airLimit;\n                        if (currAir > airLimit) {\n                            validTeam = false;\n                        } else if (currAir !== checkNum) {\n                            validTeam = false;\n                        } else {\n                            maxRel += checkNum;\n                        }\n                    }\n                    if (relGndTotal > 0) {\n                        let checkNum = relGndTotal < gndLimit ? relGndTotal : gndLimit;\n                        if (currGnd > gndLimit) {\n                            validTeam = false;\n                        } else if (currGnd !== checkNum) {\n                            validTeam = false;\n                        } else {\n                            maxRel += checkNum;\n                        }\n                    }\n                    let airMaxIncrease = reqAir > 2 ? reqAir - 2 : 0;\n                    let gndMaxIncrease = reqGnd > 2 ? reqGnd - 2 : 0;\n                    if ((totalAir > 2 + airMaxIncrease || totalGnd > 2 + gndMaxIncrease) && !bad_synergy_allowed) {\n                        validTeam = false;\n                    }\n                    if (relAirTotal > 0 || relGndTotal > 0) {\n                        let bigsad = -1;\n                    }\n                    if (validTeam) {\n                        if (bonusList.length > 0) {\n                            let bigsad = -1;\n                        }\n                        //First confirm the the combination satisfies all bonuses\n                        for(let i = 0; i < bonusList.length; i++){\n                            let bonus = bonusList[i];\n                            let pass = false;\n                            //Pet being forcefull included, needs to be here\n                            if (bonus.placement === \"team\") {\n                                let currCount = 0;\n                                for(let j = 0; j < prevCombination.length; j++){\n                                    let pet1 = prevCombination[j];\n                                    if (pet1.ID === bonus.pet.ID) {\n                                        //Fake means its a rel pet\n                                        if (bonus.parameters.fake) {\n                                            //Check if we have too many air/gnd pets before adding this one in\n                                            // if (pet.Type === 1 && currGnd > gndLimit) {\n                                            //     continue;\n                                            // }\n                                            // else if (currAir > airLimit) {\n                                            //     continue;\n                                            // }\n                                            fakeRel++;\n                                        } else {\n                                            exact++;\n                                            if (pet1.Type === 1) {\n                                                reqGnd++;\n                                            } else {\n                                                reqAir++;\n                                            }\n                                        }\n                                        currCount++;\n                                    }\n                                }\n                                if (currCount > 0) {\n                                    // console.log(`we good`);\n                                    pass = true;\n                                } else if (!bonus.parameters.fake) {\n                                    // console.log(`we not good`);\n                                    validTeam = false;\n                                    pass = false;\n                                    break;\n                                }\n                            } else if (bonus.requiredNumber > 0) {\n                                let currCount = 0;\n                                for(let j = 0; j < prevCombination.length; j++){\n                                    let pet1 = prevCombination[j];\n                                    if (pet1.BonusList.find((a)=>a.ID === bonus.bonus.id)) {\n                                        currCount++;\n                                        exact++;\n                                    }\n                                }\n                                if (currCount >= bonus.requiredNumber) {\n                                    // console.log(`we good`);\n                                    pass = true;\n                                } else {\n                                    // console.log(`we not good`);\n                                    validTeam = false;\n                                    pass = false;\n                                    break;\n                                }\n                            } else if (bonus.exactNumber > -1) {\n                                let currCount = 0;\n                                for(let j = 0; j < prevCombination.length; j++){\n                                    let pet1 = prevCombination[j];\n                                    if (pet1.BonusList.find((a)=>a.ID === bonus.bonus.id)) {\n                                        currCount++;\n                                        exact++;\n                                    }\n                                }\n                                if (currCount === bonus.exactNumber) {\n                                    // console.log(`we good`);\n                                    pass = true;\n                                } else {\n                                    // console.log(`we not good`);\n                                    validTeam = false;\n                                    pass = false;\n                                    break;\n                                }\n                            } else if (bonus.bonus.placement === \"rel\") {\n                                let currCount = 0;\n                                let maxCounter = 0;\n                                for(let j = 0; j < prevCombination.length; j++){\n                                    let pet1 = prevCombination[j];\n                                    if (pet1.BonusList.find((a)=>a.ID === bonus.bonus.id)) {\n                                        maxCounter++;\n                                        fakeRel++;\n                                    }\n                                // if (bonus.tempRequired > 0)\n                                //     if (bonus.tempRequiredPets.find((a) => a.ID === pet.ID)) {\n                                //         currCount++;\n                                //     }\n                                }\n                                if (maxCounter <= bonus.bonus.amount) {\n                                    //Check that we have some of the required pets, but not exceeding the max amount\n                                    if (bonus.tempRequired > 0) {\n                                        if (bonus.bonus.amount < bonus.tempRequired && maxCounter === bonus.bonus.amount || //max is < required (i.e. we could fit 4 but max is set to 2) -> ensure # pets === max\n                                        maxCounter >= bonus.tempRequired //Max is >= required, ensure #pet >= required\n                                        ) {\n                                            // console.log(`we good`);\n                                            pass = true;\n                                        } else {\n                                            // console.log(`we not good`);\n                                            validTeam = false;\n                                            pass = false;\n                                            break;\n                                        }\n                                    } else {\n                                        pass = true;\n                                    }\n                                } else {\n                                    validTeam = false;\n                                    pass = false;\n                                    break;\n                                }\n                            } else if (bonus.placement === \"relative\") {}\n                            //`eq` or `min` isn't active, but needs to reserve certain pets\n                            if (bonus.tempMax || bonus.tempMax === 0 && !bonus.disabled && bonus.disabled !== undefined) {\n                                let currCount = 0;\n                                for(let j = 0; j < prevCombination.length; j++){\n                                    let pet1 = prevCombination[j];\n                                    if (bonus.pets.find((a)=>a.ID === pet1.ID)) {\n                                        currCount++;\n                                    }\n                                }\n                                if (currCount <= bonus.tempMax) {\n                                    // console.log(`we good`);\n                                    pass = true;\n                                } else {\n                                    // console.log(`we not good`);\n                                    validTeam = false;\n                                    pass = false;\n                                    break;\n                                }\n                            }\n                            if (pass) {\n                                bonus.passed++;\n                            }\n                        }\n                        // for (let x = 0; x < bonusList.length; x++) {\n                        //     let temp_inner = bonusList[x];\n                        //     if (temp_inner.placement) {\n                        //         //bigsad = -1 note does not handle the rel filter for bonuses very well\n                        //         if (temp_inner.parameters.fake) {\n                        //             let pet = temp_inner.pet;\n                        //             if (pet.Type === 1 && relGndTotal > gndLimit) {\n                        //                 continue;\n                        //             }\n                        //             else if (relAirTotal > airLimit) {\n                        //                 continue;\n                        //             }\n                        //             maxRel++;\n                        //         }\n                        //     }\n                        // }\n                        //Check if we have all the req pets, and enough rel pets\n                        if (maxRel > 0 && validTeam) {\n                            //There are more recommended than we can fit, so just make sure he have enough\n                            if (maxRel + exact > maxPets) {\n                                maxRel = maxPets - exact;\n                            }\n                            if (fakeRel < maxRel) {\n                                validTeam = false;\n                            } else {\n                                validTeam = true;\n                            }\n                        }\n                        if (validTeam) {\n                            let bigsad = -1;\n                        }\n                        if (validTeam) {\n                            let id = \"\";\n                            for(let i = 0; i < prevCombination.length; i++){\n                                id = id + prevCombination[i].ID;\n                                if (i + 1 !== prevCombination.length) {\n                                    id = id + \",\";\n                                }\n                            }\n                            let x = {\n                                ID: id,\n                                team: prevCombination\n                            };\n                            // temp.push(x);\n                            if (best === -1) {\n                                best = {\n                                    ID: id,\n                                    team: prevCombination,\n                                    score: memoizedGroupScore(x)\n                                };\n                            } else {\n                                let cur = memoizedGroupScore(x);\n                                if (cur.damage === best.score.damage) {\n                                    if (cur.token > best.score.token) {\n                                        best = {\n                                            ID: id,\n                                            team: prevCombination,\n                                            score: cur\n                                        };\n                                    }\n                                } else if (cur.damage > best.score.damage) {\n                                    best = {\n                                        ID: id,\n                                        team: prevCombination,\n                                        score: cur\n                                    };\n                                }\n                            }\n                        }\n                    }\n                }\n                if (prevCombination.length === k) {\n                    return;\n                }\n                for(let i = start; i < array.length; i++){\n                    f(i + 1, [\n                        ...prevCombination,\n                        array[i]\n                    ]);\n                }\n            };\n            f(0, []);\n            if (best.team) best.team.sort((a, b)=>{\n                if (a.Type === b.Type) {\n                    return a.ID - b.ID;\n                }\n                return a.Type - b.Type;\n            });\n            return best;\n        };\n        let time1 = new Date();\n        let time2 = new Date();\n        let time3 = new Date();\n        let time4 = new Date();\n        let bestGroups = [];\n        let petsCollection = PETSCOLLECTION.filter((inner_pet)=>{\n            if (inner_pet.ID in whitelist) {\n                whitelist[inner_pet.ID].pet = inner_pet;\n            }\n            return !(inner_pet.ID in blackList) && !(inner_pet.ID in whitelist);\n        });\n        for(let g = 0; g < numGroups; g++){\n            let remainingGroups = numGroups - g;\n            let requiredPetsOverall = [];\n            let requiredBonuses = {};\n            let requiredPetBonusMap = {};\n            let requiredPetsByBonus = [];\n            let whiteListReqPets = [];\n            for (const [key, value] of Object.entries(whitelist)){\n                if (value.parameters.team === g) {\n                    if (!petsMap[value.pet.ID]) {\n                        continue;\n                    }\n                    whiteListReqPets.push(value);\n                    petsCollection.push(value.pet);\n                    requiredPetsOverall.push(value.pet);\n                }\n            }\n            if (activeBonuses.length > 0) {\n                //NOTE later need to add logic to determine if a bonus met its criteria or not before adding!! (in the case of early termination like theres only enough for 2 teams, and its fully used)\n                for(let j = 0; j < activeBonuses.length; j++){\n                    requiredBonuses[activeBonuses[j].id] = activeBonuses[j];\n                    requiredPetBonusMap[activeBonuses[j].id] = {\n                        bonus: activeBonuses[j],\n                        pets: [],\n                        active: true\n                    };\n                }\n                petsCollection.forEach((currPet)=>{\n                    if (currPet.ID in blackList) return;\n                    currPet.BonusList.forEach((currBonus)=>{\n                        if (currBonus.ID in requiredBonuses) {\n                            if (requiredBonuses[currBonus.ID].placement === \"top\") {\n                                requiredPetsOverall.push(currPet);\n                            }\n                            requiredPetBonusMap[currBonus.ID].pets.push(currPet);\n                        }\n                    });\n                });\n                //Check the bonuses placement, and if it needs to be added (top is always active)\n                for(let j = 0; j < activeBonuses.length; j++){\n                    let currBonus = requiredPetBonusMap[activeBonuses[j].id];\n                    if (currBonus.bonus.placement === \"bottom\") {\n                        //Need to check that it is time to place these or not\n                        let numPets = currBonus.pets.length;\n                        let requiredGroups = 0;\n                        let remainder;\n                        let disabled = false;\n                        let max = 0; // in case of min 1/team,  3 pets total among 3 groups, max is 1 - can not be 0 (is disabled)\n                        switch(currBonus.bonus.equation){\n                            case \"min\":\n                                //If there are not enough pets to meet the min, then set the min to # of pets\n                                //Not enough pets at all, do not reserve current pets\n                                if (numPets < currBonus.bonus.amount) {\n                                    remainder = 0;\n                                    disabled = true;\n                                } else {\n                                    //While the min is possible, we need to check whether we should silently enforce a max, to populate future groups\n                                    // if (remainingGroups <= requiredGroups) {\n                                    let maxTemp = remainingGroups * currBonus.bonus.amount;\n                                    if (numPets <= maxTemp) {\n                                        max = currBonus.bonus.amount;\n                                    }\n                                    // }\n                                    remainder = numPets % currBonus.bonus.amount;\n                                    numPets -= remainder;\n                                    requiredGroups = numPets >= 0 ? Math.ceil(numPets / currBonus.bonus.amount) : 0;\n                                }\n                                break;\n                            case \"max\":\n                                break;\n                            case \"eq\":\n                                //Not enough pets at all, do not reserve current pets\n                                if (numPets < currBonus.bonus.amount) {\n                                    remainder = 0;\n                                    disabled = true;\n                                } else {\n                                    let maxTemp = remainingGroups * currBonus.bonus.amount;\n                                    if (numPets <= maxTemp) {\n                                        max = currBonus.bonus.amount;\n                                    }\n                                    remainder = numPets % currBonus.bonus.amount;\n                                    numPets -= remainder;\n                                    requiredGroups = currBonus.pets.length >= currBonus.bonus.amount ? Math.ceil(numPets / currBonus.bonus.amount) : 0;\n                                }\n                                break;\n                            default:\n                                break;\n                        }\n                        //Time to slot in the pets\n                        if (remainingGroups <= requiredGroups) {\n                            requiredPetBonusMap[currBonus.bonus.id].tempMax = max;\n                            currBonus.pets.forEach((bonusPet)=>{\n                                requiredPetsOverall.push(bonusPet);\n                            });\n                        } else {\n                            let finalBonusPets = [];\n                            //Need to ensure we don't reserve pets that are whitelisted to go into a certain team, if that team is now\n                            for(let x = 0; x < requiredPetBonusMap[currBonus.bonus.id].pets.length; x++){\n                                let temp_curr = requiredPetBonusMap[currBonus.bonus.id].pets[x];\n                                if (temp_curr.ID in whitelist) {\n                                    if (whitelist[temp_curr.ID].placement === \"team\") {\n                                        if (whitelist[temp_curr.ID].parameters.team === g) {\n                                            continue;\n                                        }\n                                    }\n                                }\n                                finalBonusPets.push(temp_curr);\n                            }\n                            requiredPetBonusMap[currBonus.bonus.id].pets = finalBonusPets;\n                            requiredPetBonusMap[currBonus.bonus.id].active = false; //Only prevents enforcing the required pets pet team\n                            requiredPetBonusMap[currBonus.bonus.id].tempMax = remainder;\n                            requiredPetBonusMap[currBonus.bonus.id].disabled = disabled;\n                        }\n                    } else if (currBonus.bonus.placement === \"top\") {\n                        let numPets = currBonus.pets.length;\n                        let requiredGroups = 0;\n                        let remainder;\n                        let disabled = false;\n                        let max = 0; // in case of min 1/team,  3 pets total among 3 groups, max is 1 - can not be 0 (is disabled)\n                        let maxTemp = remainingGroups * currBonus.bonus.amount;\n                        if (numPets <= maxTemp) {\n                            max = currBonus.bonus.amount;\n                        }\n                        requiredPetBonusMap[currBonus.bonus.id].tempMax = max;\n                    }\n                }\n                //Calculate how many pets are actually supposed to go into this team NOTE LATER also if they should even be added in the first place\n                for(let j = 0; j < activeBonuses.length; j++){\n                    let temp = requiredPetBonusMap[activeBonuses[j].id];\n                    if (!temp.active) continue;\n                    let requiredNumber = 0;\n                    let exactNumber = -1;\n                    temp.hardFail = false;\n                    switch(temp.bonus.equation){\n                        case \"min\":\n                            //If there are not enough pets to meet the min, then set the min to # of pets\n                            // requiredNumber = temp.pets.length > temp.bonus.amount ? temp.bonus.amount : temp.pets.length\n                            if (temp.bonus.amount > temp.pets.length) {\n                                // FAILED filter\n                                requiredNumber = 0;\n                                temp.hardFail = true;\n                            } else requiredNumber = temp.bonus.amount;\n                            break;\n                        case \"max\":\n                            break;\n                        case \"eq\":\n                            // exactNumber = temp.pets.length > temp.bonus.amount ? temp.bonus.amount : temp.pets.length\n                            if (temp.bonus.amount > temp.pets.length) {\n                                // FAILED filter\n                                exactNumber = -1;\n                                temp.hardFail = true;\n                            } else exactNumber = temp.bonus.amount;\n                            break;\n                        default:\n                            break;\n                    }\n                    temp.requiredNumber = requiredNumber;\n                    temp.exactNumber = exactNumber;\n                }\n            }\n            //Get a subset of pets: the required based on bonuses, any that have dmgBonus or timeBonus, up to 4 more for max raw dungeonDamage\n            let finalPetsCollection = this.getBestDamagePets(petsCollection, defaultRank, {\n                requiredPets: requiredPetsOverall\n            });\n            //Mark every requiredBonus as failed (to check what passed at least once)\n            for (const [key, value] of Object.entries(requiredPetBonusMap)){\n                value.passed = 0;\n            }\n            time1 = new Date();\n            let ignoreCustomBonuses = false; //In the case whitelist is possible, but only with customs ignored\n            let skipChecks = false; //If it fails no matter what, don't bother adding bonuses in for subsequent best team generation\n            let bonusList = Object.values(requiredPetBonusMap);\n            for(let j = 0; j < whiteListReqPets.length; j++){\n                bonusList.push(whiteListReqPets[j]);\n            }\n            let combinations = getCombinationsInner(finalPetsCollection, Math.min(k, finalPetsCollection.length), bonusList);\n            time2 = new Date();\n            console.log(\"time to get combinations \".concat(combinations.length, \": \").concat((time2 - time1) / 1000, \" seconds\"));\n            //Check if we can create valid teams with only whitelist pets\n            if (combinations === -1 && whiteListReqPets.length > 0) {\n                bonusList = [];\n                for(let j = 0; j < whiteListReqPets.length; j++){\n                    bonusList.push(whiteListReqPets[j]);\n                }\n                combinations = getCombinationsInner(finalPetsCollection, Math.min(k, finalPetsCollection.length), bonusList);\n                if (combinations === -1) {\n                    skipChecks = true;\n                } else {\n                    ignoreCustomBonuses = true;\n                }\n            }\n            if (combinations === -1) {\n                skipChecks = true;\n            }\n            let allPassed = true;\n            //Check if any of the filters failed, and explain which + why\n            for (const [key, value] of Object.entries(requiredPetBonusMap)){\n                if (!(key in failedFiltersObj)) {\n                    if (!value.passed || value.hardFail) {\n                        let tempMsg = \"Filter failed on group \".concat(g + 1, \":\\n\");\n                        switch(value.bonus.equation){\n                            case \"min\":\n                                tempMsg += \"not enough pets, min \".concat(value.bonus.amount, \" but \").concat(value.pets.length, \" remain\");\n                                break;\n                            case \"max\":\n                                break;\n                            case \"eq\":\n                                tempMsg += \"not enough pets, req. \".concat(value.bonus.amount, \" but \").concat(value.pets.length, \" remain\");\n                                break;\n                            default:\n                                throw new Error(\"impossible case\");\n                        }\n                        failedFiltersObj[key] = tempMsg;\n                        allPassed = false;\n                    }\n                }\n            }\n            //Meaning there are just no possible combinations\n            if (skipChecks) {\n                if (Object.values(requiredPetBonusMap).length > 0) {\n                    if (!(\"generic\" in failedFiltersObj)) {\n                        failedFiltersObj[\"generic\"] = \"Individual filters all succeeded, but the combination of all is impossible starting group \".concat(g + 1);\n                    }\n                }\n                break;\n            } else if (!ignoreCustomBonuses) {\n                let bestCurrTeamScore = this.calculateGroupScore(combinations.team, defaultRank);\n                let score = bestCurrTeamScore.groupScore;\n                let individualRel = Object.values(whitelistRel);\n                if (activeBonuses.length > 0 || individualRel.length > 0) {\n                    let added = false;\n                    for(let j = 0; j < individualRel.length; j++){\n                        let curBonus = individualRel[j];\n                        let mult = curBonus.parameters.damageBias / 100;\n                        let cutOff = score * mult;\n                        let tmLength = combinations.team.length;\n                        let amountToAdd = 0;\n                        let bonusPet = petsMap[curBonus.id];\n                        let dmg = this.calculatePetBaseDamage(bonusPet, defaultRank);\n                        if (!bonusPet) continue;\n                        bonusPet.BonusList.forEach((e)=>{\n                            let modifiedAddition = 0;\n                            //Dng dmg\n                            if (e.ID === 1013) {\n                                dmg *= 1 + this.EXP_DMG_MOD;\n                                if (tmLength > 1) {\n                                    //Get avg base group score, then remove 1, apply mult (iplier), apply modifier, add it\n                                    modifiedAddition += bestCurrTeamScore.baseGroupScore / tmLength * (tmLength - 1) * mult * this.EXP_DMG_MOD;\n                                // modifiedAddition += (this.calculatePetBaseDamage(bonusPet, defaultRank) * 3 * mult * (this.EXP_DMG_MOD));\n                                } else {\n                                    modifiedAddition = bestCurrTeamScore.baseGroupScore * mult * this.EXP_DMG_MOD;\n                                }\n                                amountToAdd += modifiedAddition;\n                            } else if (e.ID === 1012) {\n                                dmg *= 1 + this.EXP_TIME_MOD;\n                                if (tmLength > 1) {\n                                    //Get avg base group score, then remove 1, apply mult (iplier), apply modifier, add it\n                                    modifiedAddition += this.calculatePetBaseDamage(bonusPet, defaultRank) * 3 * mult * this.EXP_TIME_MOD;\n                                } else {\n                                    modifiedAddition = bestCurrTeamScore.baseGroupScore * mult * this.EXP_TIME_MOD;\n                                }\n                                amountToAdd += modifiedAddition;\n                            }\n                        });\n                        dmg += amountToAdd;\n                        if (dmg > cutOff) {\n                            added = true;\n                            let newBonus = JSON.parse(JSON.stringify(curBonus));\n                            // newBonus.placement = 'relative';\n                            newBonus.placement = \"team\";\n                            newBonus.parameters.team = g;\n                            newBonus.pet = bonusPet;\n                            newBonus.parameters.fake = true;\n                            //Since it is a single pet, and it *has* to be inserted now, we can hitchike off of the built in `whilteListReqPets` system\n                            whiteListReqPets.push(newBonus);\n                            //Add pet into list of pets to combine, if it's not already there\n                            let exists = finalPetsCollection.find((a)=>a.ID === bonusPet.ID);\n                            if (!exists) {\n                                finalPetsCollection.push(bonusPet);\n                            }\n                        }\n                    }\n                    for(let j = 0; j < activeBonuses.length; j++){\n                        let curBonus = activeBonuses[j];\n                        let mult = curBonus.relThresh / 100;\n                        let cutOff = score * mult;\n                        let counterBonus = 0;\n                        let innerAdded = false;\n                        let temp = requiredPetBonusMap[curBonus.id];\n                        if (curBonus.placement === \"rel\") {\n                            let bonusPets = temp.pets;\n                            bonusPets.forEach((bonusPet)=>{\n                                let dmg = this.calculatePetBaseDamage(bonusPet, defaultRank);\n                                let tmLength = combinations.team.length;\n                                let amountToAdd = 0;\n                                bonusPet.BonusList.forEach((e)=>{\n                                    let modifiedAddition = 0;\n                                    //Dng dmg\n                                    if (e.ID === 1013) {\n                                        dmg *= 1 + this.EXP_DMG_MOD;\n                                        if (tmLength > 1) {\n                                            //Get avg base group score, then remove 1, apply mult (iplier), apply modifier, add it\n                                            modifiedAddition += bestCurrTeamScore.baseGroupScore / tmLength * (tmLength - 1) * mult * this.EXP_DMG_MOD;\n                                        // modifiedAddition += (this.calculatePetBaseDamage(bonusPet, defaultRank) * 3 * mult * (this.EXP_DMG_MOD));\n                                        } else {\n                                            modifiedAddition = bestCurrTeamScore.baseGroupScore * mult * this.EXP_DMG_MOD;\n                                        }\n                                        amountToAdd += modifiedAddition;\n                                    } else if (e.ID === 1012) {\n                                        dmg *= 1 + this.EXP_TIME_MOD;\n                                        if (tmLength > 1) {\n                                            //Get avg base group score, then remove 1, apply mult (iplier), apply modifier, add it\n                                            modifiedAddition += bestCurrTeamScore.baseGroupScore / tmLength * (tmLength - 1) * mult * this.EXP_TIME_MOD;\n                                        } else {\n                                            modifiedAddition = bestCurrTeamScore.baseGroupScore * mult * this.EXP_TIME_MOD;\n                                        }\n                                        amountToAdd += modifiedAddition;\n                                    }\n                                });\n                                dmg += amountToAdd;\n                                if (dmg > cutOff) {\n                                    added = true;\n                                    innerAdded = true;\n                                    temp.active = true;\n                                    temp.tempMin = true;\n                                    temp.tempRequired = temp.tempRequired !== 0 && temp.tempRequired ? temp.tempRequired + 1 : 1;\n                                    if (!temp.tempRequiredPets) {\n                                        temp.tempRequiredPets = [];\n                                    }\n                                    temp.tempRequiredPets.push(bonusPet);\n                                    let exists = finalPetsCollection.find((a)=>a.ID === bonusPet.ID);\n                                    if (!exists) {\n                                        finalPetsCollection.push(bonusPet);\n                                    // exists = requiredPetsOverall.find((a) => a.ID === bonusPet.ID);\n                                    // if (!exists) {\n                                    //     requiredPetsOverall.push(bonusPet);\n                                    // }\n                                    }\n                                }\n                            });\n                            if (!innerAdded) {\n                                temp.tempMin = null;\n                                temp.tempRequired = 0;\n                                temp.tempRequiredPets = [];\n                                temp.active = false;\n                            }\n                        }\n                    }\n                    //At least 1 rel pet was added, recalc teams with it\n                    if (added) {\n                        // finalPetsCollection = this.getBestDamagePets(petsCollection, defaultRank, { requiredPets: requiredPetsOverall });\n                        time1 = new Date();\n                        let bonusList = Object.values(requiredPetBonusMap);\n                        for(let j = 0; j < whiteListReqPets.length; j++){\n                            // if (whiteListReqPets[j].placement === `relative`) {\n                            //     // finalPetsCollection.push(whiteListReqPets[j].pet)\n                            // }\n                            // else {\n                            bonusList.push(whiteListReqPets[j]);\n                        // }\n                        }\n                        let combinations_rel = getCombinationsInner(finalPetsCollection, Math.min(k, finalPetsCollection.length), bonusList);\n                        console.log(\"got new combinations after the rel calcs\");\n                        if (combinations_rel !== -1) {\n                            //Only filter out the fake `rel` whitelisted pets, if they WERE selected by the combo\n                            whiteListReqPets = whiteListReqPets.filter((e)=>{\n                                let temp = combinations_rel;\n                                if (!e.parameters.fake) {\n                                    return true;\n                                } else {\n                                    let found = combinations_rel.team.find((inner_pet)=>inner_pet.ID === e.id);\n                                    return !found;\n                                }\n                            });\n                        }\n                        //Only hard crash in case of no backup team that is possible\n                        if (combinations_rel === -1 && whiteListReqPets.length === 0) {\n                            if (!(\"generic\" in failedFiltersObj)) {\n                                failedFiltersObj[\"generic\"] = \"Individual filters all succeeded, but the combination of all is impossible starting group \".concat(g + 1, \" (too many relative pets in one team)\");\n                            }\n                            break;\n                        } else if (combinations_rel !== -1) {\n                            combinations = combinations_rel;\n                            //Also need to delete all the rel whitelists from future teams, only if they exist\n                            for(let x = 0; x < bonusList.length; x++){\n                                if (bonusList[x].id in whitelistRel && combinations_rel.team.find((inner_pet)=>inner_pet.ID === bonusList[x].id)) {\n                                    delete whitelistRel[bonusList[x].id];\n                                }\n                            }\n                        }\n                    }\n                }\n                bestGroups.push(combinations.team);\n                //remove whitelisted relative \n                for(let i = 0; i < combinations.team.length; i++){\n                    if (combinations.team[i].ID in whitelistRel) {\n                        delete whitelistRel[combinations.team[i].ID];\n                    }\n                }\n                petsCollection = petsCollection.filter((pet1)=>{\n                    let res = true;\n                    for(let i = 0; i < combinations.team.length; i++){\n                        if (combinations.team[i].ID === pet1.ID) {\n                            res = false;\n                            break;\n                        }\n                    }\n                    return res;\n                });\n            } else {\n                bestGroups.push(combinations.team);\n                //remove whitelisted relative \n                for(let i = 0; i < combinations.team.length; i++){\n                    if (combinations.team[i].ID in whitelistRel) {\n                        delete whitelistRel[combinations.team[i].ID];\n                    }\n                }\n                //Remove the pets\n                petsCollection = petsCollection.filter((pet1)=>{\n                    let res = true;\n                    for(let i = 0; i < combinations.team.length; i++){\n                        if (combinations.team[i].ID === pet1.ID) {\n                            res = false;\n                            break;\n                        }\n                    }\n                    return res;\n                });\n            }\n        }\n        time4 = new Date();\n        console.log(\"time to get best combo: \".concat((time4 - time3) / 1000, \" seconds\"));\n        if (other === null || other === void 0 ? void 0 : other.setFailedFilters) {\n            other.setFailedFilters(failedFiltersObj);\n        }\n        // // Reset any auto placements back to proper auto for visual purposes\n        // for (const [key, value] of Object.entries(autoPets)) {\n        //     autoPets[key].placement = 'auto';\n        // }\n        let swapHappened = true;\n        let numSwaps = -1;\n        while(swapHappened){\n            numSwaps++;\n            swapHappened = false;\n            let copyGroups = JSON.parse(JSON.stringify(bestGroups));\n            const maxSwaps = 2;\n            // Go over each pet and bubble sort if possible\n            for(let group_index = 0; group_index < copyGroups.length; group_index++){\n                let team = copyGroups[group_index];\n                for(let pet_index = 0; pet_index < team.length; pet_index++){\n                    let pet1 = team[pet_index];\n                    let swapPet = null;\n                    let group = team;\n                    let tooHigh = false;\n                    let tooLow = false;\n                    // This pet was placed by `group` by user, do not shift!\n                    if (lockedPets[pet1.ID]) {\n                        continue;\n                    }\n                    //Might not need this since things start low and go up\n                    //First check if the pet should be on a lower team\n                    //Do this by seeing if a swap gives a higher damage on current team\n                    if (group_index < bestGroups.length - 1) {\n                        let subsequentGroup = copyGroups[group_index + 1];\n                        let triedPets = {};\n                        let currentGroupScore = this.calculateGroupScore(group, defaultRank).groupScore;\n                        for(let i = 0; i < maxSwaps; i++){\n                            for(let j = 0; j < subsequentGroup.length; j++){\n                                let newPet = subsequentGroup[j];\n                                if (newPet.Type === pet1.Type && !triedPets[newPet.ID]) {\n                                    triedPets[newPet.ID] = newPet;\n                                    let newGroup = JSON.parse(JSON.stringify(team));\n                                    newGroup[pet_index] = newPet;\n                                    let newScore = this.calculateGroupScore(newGroup, defaultRank).groupScore;\n                                    // There is a better pet from lower team to grab!\n                                    if (newScore > currentGroupScore) {\n                                        let bigsad = -1;\n                                        tooHigh = true;\n                                    // swapHappened = true;\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    //Second check if the pet should be on a higher team\n                    //Do this by seeing if a swap gives a higher damage on to the previous team\n                    if (!tooHigh && group_index > 0) {\n                        let currentCounter = group_index - 1;\n                        while(currentCounter >= 0){\n                            let previousGroup = copyGroups[currentCounter];\n                            let triedPets = {};\n                            let currentGroupScore = this.calculateGroupScore(previousGroup, defaultRank).groupScore;\n                            for(let i = 0; i < maxSwaps; i++){\n                                for(let j = 0; j < previousGroup.length; j++){\n                                    let newPet = previousGroup[j];\n                                    if (lockedPets[newPet.ID]) {\n                                        continue;\n                                    }\n                                    if (newPet.Type === pet1.Type && !triedPets[newPet.ID]) {\n                                        // if (!triedPets[newPet.ID]) {\n                                        triedPets[newPet.ID] = newPet;\n                                        let newGroup = JSON.parse(JSON.stringify(previousGroup));\n                                        newGroup[j] = pet1;\n                                        let newScore = this.calculateGroupScore(newGroup, defaultRank).groupScore;\n                                        // There is a better pet from lower team to grab!\n                                        if (newScore > currentGroupScore) {\n                                            tooLow = true;\n                                            swapHappened = true;\n                                            bestGroups[group_index][pet_index] = JSON.parse(JSON.stringify(newPet));\n                                            bestGroups[currentCounter][j] = JSON.parse(JSON.stringify(pet1));\n                                            let bigsad = -1;\n                                        }\n                                        break;\n                                    }\n                                    if (swapHappened) {\n                                        break;\n                                    }\n                                }\n                                if (swapHappened) {\n                                    break;\n                                }\n                            }\n                            if (swapHappened) {\n                                break;\n                            }\n                            currentCounter--;\n                        }\n                    }\n                    if (swapHappened) {\n                        break;\n                    }\n                }\n                if (swapHappened) {\n                    break;\n                }\n            }\n        }\n        console.log(\"num swaps: \".concat(numSwaps));\n        bestGroups.forEach((inner_group)=>{\n            inner_group.sort((a, b)=>a.ID - b.ID);\n            inner_group.sort((a, b)=>a.Type - b.Type);\n        });\n        return bestGroups;\n    },\n    calcBestTokenGroup: function(petsCollection, defaultRank, numGroups, other) {\n        const k = 4; // Size of each group\n        numGroups = numGroups ? numGroups : 7;\n        let damageMode = 1; //1 = max damage, 2 = min\n        const memo = {};\n        const memoizedGroupScore = (innerGroup)=>{\n            const key = innerGroup.ID;\n            if (!memo[key] || memo[key]) {\n                let res = this.calculateGroupScore(innerGroup.team, defaultRank);\n                let sum = res.tokenMult;\n                memo[key] = {\n                    token: sum,\n                    damage: res.groupScore,\n                    other: res\n                };\n            }\n            return memo[key];\n        };\n        const getCombinationsInner = (array, k, requiredPetsObj)=>{\n            // let temp = [];\n            let best = -1;\n            const f = (start, prevCombination)=>{\n                let required = 0;\n                let ignored = 0;\n                let requiredPets = [];\n                let ignoredPets = [];\n                if (requiredPetsObj) {\n                    required = requiredPetsObj.min ? requiredPetsObj.min : 0;\n                    requiredPets = requiredPetsObj.pets ? requiredPetsObj.pets : [];\n                    ignoredPets = requiredPetsObj.ignoredPets ? requiredPetsObj.ignoredPets : [];\n                }\n                let requiredFound = 0;\n                if (prevCombination.length > 0) {\n                    let id = \"\";\n                    for(let i = 0; i < prevCombination.length; i++){\n                        id = id + prevCombination[i].ID;\n                        if (i + 1 !== prevCombination.length) {\n                            id = id + \",\";\n                        }\n                        if (required > 0) {\n                            for(let x = 0; x < requiredPets.length; x++){\n                                if (prevCombination[i].ID == requiredPets[x].ID) requiredFound++;\n                            }\n                        }\n                        if (ignoredPets.length > 0) {\n                            for(let x = 0; x < ignoredPets.length; x++){\n                                if (prevCombination[i].ID == ignoredPets[x].ID) {\n                                    ignored++;\n                                }\n                            }\n                        }\n                    }\n                    if (requiredFound === required && ignored === 0) {\n                        let x = {\n                            ID: id,\n                            team: prevCombination\n                        };\n                        // temp.push(x);\n                        if (best === -1) {\n                            best = {\n                                ID: id,\n                                team: prevCombination,\n                                score: memoizedGroupScore(x)\n                            };\n                        } else {\n                            let cur = memoizedGroupScore(x);\n                            //Max damage\n                            if (damageMode === 1) {\n                                if (cur.damage > best.score.damage) {\n                                    best = {\n                                        ID: id,\n                                        team: prevCombination,\n                                        score: cur\n                                    };\n                                }\n                            } else {\n                                if (cur.token === best.score.token) {\n                                    // if (cur.other.tokenRewardCount === 4) {\n                                    if (cur.other.tokenRewardCount > 0) {\n                                        if (cur.damage < best.score.damage) {\n                                            best = {\n                                                ID: id,\n                                                team: prevCombination,\n                                                score: cur\n                                            };\n                                        }\n                                    } else {\n                                        if (cur.damage > best.score.damage) {\n                                            best = {\n                                                ID: id,\n                                                team: prevCombination,\n                                                score: cur\n                                            };\n                                        }\n                                    }\n                                } else if (cur.token > best.score.token) {\n                                    best = {\n                                        ID: id,\n                                        team: prevCombination,\n                                        score: cur\n                                    };\n                                }\n                            }\n                        }\n                    } else {\n                        let temper = 3;\n                    }\n                }\n                if (prevCombination.length === k) {\n                    return;\n                }\n                for(let i = start; i < array.length; i++){\n                    f(i + 1, [\n                        ...prevCombination,\n                        array[i]\n                    ]);\n                }\n            };\n            f(0, []);\n            if (best.team) best.team.sort((a, b)=>{\n                if (a.Type === b.Type) {\n                    return a.ID - b.ID;\n                }\n                return a.Type - b.Type;\n            });\n            return best;\n        };\n        let time3 = new Date();\n        let time4 = new Date();\n        let bestGroups = [];\n        for(let g = 0; g < numGroups; g++){\n            let combinations = -1;\n            let newPetsCollection = JSON.parse(JSON.stringify(petsCollection));\n            let numTokens = 0;\n            let avgTokenPetDmg = 0;\n            let tokenPets = [];\n            let maxDmgPet;\n            let avgdMaxDmg = 0;\n            let tknAir = 0;\n            let tknGnd = 0;\n            newPetsCollection.forEach((pet1)=>{\n                pet1.BonusList.forEach((bonus)=>{\n                    //token bonus\n                    if (bonus.ID === 1016) {\n                        tokenPets.push(pet1);\n                        avgTokenPetDmg += this.calculatePetBaseDamage(pet1, defaultRank);\n                        numTokens++;\n                        if (pet1.Type === 1) {\n                            tknGnd++;\n                        } else if (pet1.Type === 2) {\n                            tknAir++;\n                        }\n                    }\n                });\n            });\n            avgTokenPetDmg /= numTokens;\n            newPetsCollection = this.getBestDamagePets(newPetsCollection, defaultRank, {\n                requiredPets: tokenPets\n            });\n            newPetsCollection = newPetsCollection.sort((a, b)=>this.calculatePetBaseDamage(b, defaultRank) - this.calculatePetBaseDamage(a, defaultRank));\n            for(let i = 0; i < 2; i++){\n                avgdMaxDmg += this.calculatePetBaseDamage(newPetsCollection[i], defaultRank);\n            }\n            avgdMaxDmg /= 2;\n            let bestDamageTeam = this.calcBestDamageGroup(newPetsCollection, defaultRank, 1)[0];\n            avgdMaxDmg = bestDamageTeam ? this.calculateGroupScore(bestDamageTeam, defaultRank) : [];\n            //Create a trash team first\n            if (numTokens >= 4 && tknAir >= 2 && tknGnd >= 2) {\n                //Only force 4 if there are enough for a full synergy\n                damageMode = 2; //Set damage mode to min\n                combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length), {\n                    pets: tokenPets,\n                    min: 4\n                });\n                damageMode = 1; //Set damage back to max\n            } else if (numTokens === 1) {\n                //If it's the last team, slot it in forcefully\n                if (g === numGroups - 1) {\n                    combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length), {\n                        pets: tokenPets,\n                        min: tokenPets.length\n                    });\n                } else {\n                    combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length));\n                }\n            } else if (numTokens > 1) {\n                let percent = (100 - other.tokenDamageBias) / 100;\n                let cutOff = percent * avgdMaxDmg.groupScore; //% of highest available pet's base damage          \n                cutOff /= 5.75; // used for comparing with full team score\n                let minPets = 2;\n                if (tknAir > 1 && tknGnd > 0 || tknGnd > 1 && tknAir > 0) {\n                    minPets = 3;\n                }\n                let numTokenGroups = Math.ceil(numTokens / minPets);\n                //Maximise this team, this turn\n                if (numTokenGroups >= numGroups - g) {\n                    //There are not enough groups for all token pets\n                    if (numTokenGroups - (numGroups - g) >= 0) {\n                        damageMode = 1;\n                    } else damageMode = 2;\n                    combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length), {\n                        pets: tokenPets,\n                        min: minPets\n                    });\n                    damageMode = 1;\n                } else if (avgTokenPetDmg > cutOff) {\n                    let remainingGroups = numGroups - g;\n                    //There are not enough groups for all token pets\n                    if (remainingGroups - numTokenGroups >= 0) {\n                        damageMode = 1;\n                    } else damageMode = 2;\n                    //Maximise this team\n                    combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length), {\n                        pets: tokenPets,\n                        min: minPets\n                    });\n                    damageMode = 1;\n                } else {\n                    combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length), {\n                        pets: [],\n                        min: 0,\n                        ignoredPets: tokenPets\n                    });\n                }\n            } else {\n                combinations = getCombinationsInner(newPetsCollection, Math.min(k, newPetsCollection.length));\n            }\n            if (combinations === -1) {\n                break;\n            } else {\n                let temp = memoizedGroupScore(combinations);\n                bestGroups.push(combinations.team);\n                petsCollection = petsCollection.filter((pet1)=>{\n                    let res = true;\n                    for(let i = 0; i < combinations.team.length; i++){\n                        if (combinations.team[i].ID === pet1.ID) {\n                            res = false;\n                            break;\n                        }\n                    }\n                    return res;\n                });\n            }\n        }\n        time4 = new Date();\n        console.log(\"time to get best combo: \".concat((time4 - time3) / 1000, \" seconds\"));\n        // bestGroups.sort()\n        return bestGroups;\n    },\n    findBestGroups: function(petsCollection, defaultRank, groupRankCritera, numGroups, other) {\n        switch(groupRankCritera){\n            case 1:\n                return this.calcBestDamageGroup(petsCollection, defaultRank, numGroups, other);\n            case 2:\n                return this.calcBestTokenGroup(petsCollection, defaultRank, numGroups, other);\n            case 3:\n                return this.calcBestDamageGroup(petsCollection, defaultRank, numGroups, other);\n        }\n    },\n    calcEquipBonus: function(pet1, bonusInner) {\n        let bonus = 1;\n        let curr = pet1;\n        if (bonusInner.ID === 23) {\n            if (curr.Level < 1) return 0;\n            let x1 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Level);\n            let x2 = Math.max(0, x1 - 45);\n            let x3 = Math.pow(1.15, x2);\n            let x4 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Rank);\n            let x5 = Math.max(0, x4 - 45);\n            let x6 = Math.pow(1.15, x5);\n            let tot3 = (1 + (24 + x3) * 0.01) * (1 + x6 * 0.01) - 1;\n            bonus = tot3;\n        } else if (bonusInner.ID === 28) {\n            if (curr.Level < 1) return 0;\n            let x1 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Level);\n            let x2 = Math.max(0, x1 - 45);\n            let x3 = Math.pow(1.15, x2);\n            let x4 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Rank);\n            let x5 = Math.max(0, x4 - 45);\n            let x6 = Math.pow(1.15, x5);\n            let tot3 = (1 + (24 + x3) * 0.001) * (1 + x6 * 0.01) - 1;\n            bonus = tot3;\n        } else if (bonusInner.ID === 29) {\n            if (curr.Level < 1) return 0;\n            let x1 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Level);\n            let x2 = Math.max(0, x1 - 45);\n            let x3 = Math.pow(1.15, x2);\n            let x4 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Rank);\n            let x5 = Math.max(0, x4 - 45);\n            let x6 = Math.pow(1.15, x5);\n            let tot3 = (1 + (24 + x3) * 0.0025) * (1 + x6 * 0.01) - 1;\n            bonus = tot3;\n        } else if (bonusInner.ID === 34) {\n            if (curr.Level < 1) return 0;\n            let x1 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Level);\n            let x2 = Math.max(0, x1 - 45);\n            let x3 = Math.pow(1.125, x2);\n            let x4 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Rank);\n            let x5 = Math.max(0, x4 - 45);\n            let x6 = Math.pow(1.15, x5);\n            let tot3 = (1 + (9 + x3) * 0.00025) * (1 + x6 * 0.001) - 1;\n            bonus = tot3;\n        } else if (bonusInner.ID === 35) {\n            if (curr.Level < 1) return 0;\n            let x1 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Level);\n            let x2 = Math.max(0, x1 - 45);\n            let x3 = Math.pow(1.125, x2);\n            let x4 = _helper_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].calculateLogarithm(1.1, curr.Rank);\n            let x5 = Math.max(0, x4 - 45);\n            let x6 = Math.pow(1.15, x5);\n            let tot3 = (1 + (9 + x3) * 5E-05) * (1 + x6 * 0.001) - 1;\n            bonus = tot3;\n        } else {\n            let x1 = Math.pow(1.0 + bonusInner.Gain, curr.Level) - 1.0;\n            let x2 = 1 + curr.Rank * 0.02;\n            bonus = x1 * x2;\n        }\n        return bonus * 100;\n    }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (helper);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvdXRpbC9wZXRIZWxwZXIuanMiLCJtYXBwaW5ncyI6Ijs7QUFBeUM7QUFFekMsSUFBSUMsU0FBUztJQUNUQyxhQUFhO0lBQ2JDLGNBQWM7SUFDZEMsa0JBQWtCO0lBQ2xCQyxlQUFlO0lBQ2ZDLGtCQUFrQjtJQUVsQkMsd0JBQXdCLFNBQVVDLElBQUcsRUFBRUMsV0FBVztRQUM5QyxNQUFNQyxZQUFZRCxjQUFjQSxjQUFjRCxpQkFBQUEsMkJBQUFBLEtBQUtHLElBQUk7UUFDdkQsTUFBTUMsU0FBU0osQ0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFLSyxpQkFBaUIsSUFBSSxPQUFNSCxZQUFZLElBQUc7UUFDOUQsT0FBT0ksT0FBT0Y7SUFDbEI7SUFDQUcsb0JBQW9CLFNBQVVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxjQUFjLEVBQUVDLEtBQUs7UUFFN0QsSUFBSUM7UUFDSixJQUFJQyxlQUFlSCxDQUFBQSwyQkFBQUEscUNBQUFBLGVBQWdCRyxZQUFZLElBQUdILGVBQWVHLFlBQVksR0FBRztRQUNoRiw2RUFBNkU7UUFDN0UsSUFBSUMsaUJBQWlCSixlQUFlSyxJQUFJLENBQUNDLHNCQUFzQixHQUFHTixlQUFlSyxJQUFJLENBQUNFLHlCQUF5QjtRQUUvRyxJQUFJLENBQUNSLE9BQU87WUFDUkEsUUFBUTtnQkFBQztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBRztnQkFBSTtnQkFBSTthQUFHO1FBQ25EO1FBQ0EsSUFBSSxDQUFDRyxRQUFRO1lBQ1RBLFNBQVNGLENBQUFBLDJCQUFBQSxxQ0FBQUEsZUFBZ0JFLE1BQU0sSUFBR0YsZUFBZUUsTUFBTSxHQUFHO1FBQzlEO1FBQ0EsSUFBSSxDQUFDRCxPQUFPO1lBQ1JBLFFBQVE7UUFDWjtRQUNBLE1BQU1PLFVBQVUsSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ1g7UUFFekMsMEJBQTBCO1FBQzFCLE1BQU1ZLFVBQVVGLFFB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UUFBUWlPLEtBQUtFO1FBQ2pCO1FBRUEsT0FBT25PLFFBQVE7SUFDbkI7QUFFSjtBQUdBLCtEQUFlM0QsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL3V0aWwvcGV0SGVscGVyLmpzP2ZjNjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdlbmVyYWxfaGVscGVyIGZyb20gJy4vaGVscGVyLmpzJztcclxuXHJcbnZhciBoZWxwZXIgPSB7XHJcbiAgICBFWFBfRE1HX01PRDogLjEsXHJcbiAgICBFWFBfVElNRV9NT0Q6IC4wNSxcclxuICAgIFNZTkVSR1lfTU9EX1NURVA6IC4yNSxcclxuICAgIEVYUF9UT0tFTl9NT0Q6IDAuMDUsXHJcbiAgICBTT1VMX0NMT1ZFUl9TVEVQOiAwLjI1LFxyXG5cclxuICAgIGNhbGN1bGF0ZVBldEJhc2VEYW1hZ2U6IGZ1bmN0aW9uIChwZXQsIGRlZmF1bHRSYW5rKSB7XHJcbiAgICAgICAgY29uc3QgcmFua0NvdW50ID0gZGVmYXVsdFJhbmsgPyBkZWZhdWx0UmFuayA6IHBldD8uUmFuaztcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBwZXQ/LkJhc2VEdW5nZW9uRGFtYWdlICogKDEuMCArIHJhbmtDb3VudCAqIDAuMDUpO1xyXG4gICAgICAgIHJldHVybiBOdW1iZXIocmVzdWx0KTtcclxuICAgIH0sXHJcbiAgICBjYWxjdWxhdGVCZXN0SG91cnM6IGZ1bmN0aW9uIChncm91cCwgaG91cnMsIHRva2VuTW9kaWZpZXJzLCBjb21ibykge1xyXG5cclxuICAgICAgICBsZXQgY2xvdmVyO1xyXG4gICAgICAgIGxldCByZXNpZHVlVG9rZW4gPSB0b2tlbk1vZGlmaWVycz8ucmVzaWR1ZVRva2VuID8gdG9rZW5Nb2RpZmllcnMucmVzaWR1ZVRva2VuIDogMDtcclxuICAgICAgICAvL2NvbnRhaW5zIGNsb3ZlciBhbmQgb3RoZXIgICAgICAgICAgICAgICAgIGNvbnRhaW5zIGFjdGl2ZSAoc3BlY2lhbCkgYm9udXNlc1xyXG4gICAgICAgIGxldCBwZF90b2tlbl9ib251cyA9IHRva2VuTW9kaWZpZXJzLmRhdGEuRXhwZWRpdGlvblRva2VuQm9udXNlcyAqIHRva2VuTW9kaWZpZXJzLmRhdGEuRXhwZWRpdGlvblJlc291cmNlQm9udXNlcztcclxuXHJcbiAgICAgICAgaWYgKCFob3Vycykge1xyXG4gICAgICAgICAgICBob3VycyA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjbG92ZXIpIHtcclxuICAgICAgICAgICAgY2xvdmVyID0gdG9rZW5Nb2RpZmllcnM/LmNsb3ZlciA/IHRva2VuTW9kaWZpZXJzLmNsb3ZlciA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghY29tYm8pIHtcclxuICAgICAgICAgICAgY29tYm8gPSAxLjBcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3ZlcmFsbCA9IHRoaXMuY2FsY3VsYXRlR3JvdXBTY29yZShncm91cCk7XHJcblxyXG4gICAgICAgIC8vaW5jbHVkZXMgcGV0IHRva2VuIGdhaW4gXHJcbiAgICAgICAgY29uc3QgdG9rZW5IUiA9IG92ZXJhbGwudG9rZW5NdWx0ICogcGRfdG9rZW5fYm9udXMgKiBjb21ibztcclxuICAgICAgICBsZXQgYmVzdCA9IHsgaG91cnM6IC0xLCB0b3RhbFRva2VuczogLTEsIGZsb29yZWQ6IC0xLCBlZmZlY2llbmN5OiAtMSB9O1xyXG4gICAgICAgIGxldCBiZXN0QXJyID0gW107XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaG91cnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGggPSBob3Vyc1tpXTtcclxuICAgICAgICAgICAgbGV0IHRvdGFsVG9rZW5zID0gdG9rZW5IUiArICgxIC8gMzYwMCkgKiB0b2tlbkhSOy8vYXNzdW1pbmcgMWhyIHJ1bnNcclxuICAgICAgICAgICAgbGV0IGZsb29yZWQgPSBNYXRoLmZsb29yKHRvdGFsVG9rZW5zKTtcclxuICAgICAgICAgICAgbGV0IGVmZmVjaWVuY3kgPSBmbG9vcmVkIC8gdG90YWxUb2tlbnM7XHJcbiAgICAgICAgICAgIGxldCB3YXN0ZWQgPSB0b3RhbFRva2VucyAtIGZsb29yZWQ7XHJcbiAgICAgICAgICAgIGxldCB3YXN0ZWRIUiA9IHdhc3RlZCAvIGg7XHJcbiAgICAgICAgICAgIGxldCB0ZW1wID0geyB3YXN0ZWRIUjogd2FzdGVkSFIsIHRva2VuSFI6IHRva2VuSFIgKyAoMSAvIDM2MDApICogdG9rZW5IUiwgd2FzdGVkOiB3YXN0ZWQsIGhvdXJzOiBoLCB0b3RhbFRva2VuczogdG90YWxUb2tlbnMsIGZsb29yZWQ6IGZsb29yZWQsIGVmZmVjaWVuY3k6IGVmZmVjaWVuY3kgfTtcclxuICAgICAgICAgICAgYmVzdEFyci5wdXNoKHRlbXApO1xyXG5cclxuICAgICAgICAgICAgLy8gaWYgKGVmZmVjaWVuY3kgPiBiZXN0LmVmZmVjaWVuY3kpIHtcclxuICAgICAgICAgICAgLy8gICAgIGJlc3RBcnIgPSBbXTtcclxuICAgICAgICAgICAgLy8gICAgIGJlc3QgPSB7IGhvdXJzOiBoLCB0b3RhbFRva2VuczogdG90YWxUb2tlbnMsIGZsb29yZWQ6IGZsb29yZWQsIGVmZmVjaWVuY3k6IGVmZmVjaWVuY3kgfTtcclxuICAgICAgICAgICAgLy8gICAgIGJlc3RBcnIucHVzaChiZXN0KTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAvLyBlbHNlIGlmIChlZmZlY2llbmN5ID09PSBiZXN0LmVmZmVjaWVuY3kpIHtcclxuICAgICAgICAgICAgLy8gICAgIGJlc3QgPSB7IGhvdXJzOiBoLCB0b3RhbFRva2VuczogdG90YWxUb2tlbnMsIGZsb29yZWQ6IGZsb29yZWQsIGVmZmVjaWVuY3k6IGVmZmVjaWVuY3kgfTtcclxuICAgICAgICAgICAgLy8gICAgIGJlc3RBcnIucHVzaChiZXN0KTtcclxuICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gYmVzdEFyci5zb3J0KChhLCBiKSA9PiB7IHJldHVybiBhLndhc3RlZCAtIGIud2FzdGVkIH0pXHJcblxyXG4gICAgICAgIC8vIGJlc3RBcnIuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIC8vICAgICBsZXQgYV93YXN0ZSA9IGdlbmVyYWxfaGVscGVyLnJvdW5kVGhyZWVEZWNpbWFsKGEud2FzdGVkSFIpXHJcbiAgICAgICAgLy8gICAgIGxldCBiX3dhc3RlID0gZ2VuZXJhbF9oZWxwZXIucm91bmRUaHJlZURlY2ltYWwoYi53YXN0ZWRIUilcclxuICAgICAgICAvLyAgICAgaWYgKGFfd2FzdGUgPT09IGJfd2FzdGUpIHtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybiBhLmhvdXJzIC0gYi5ob3VycztcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vICAgICByZXR1cm4gYV93YXN0ZSAtIGJfd2FzdGU7XHJcbiAgICAgICAgLy8gfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIGJlc3RBcnI7XHJcbiAgICB9LFxyXG4gICAgY2FsY3VsYXRlR3JvdXBTY29yZTogZnVuY3Rpb24gKGdyb3VwLCBkZWZhdWx0UmFuaykge1xyXG4gICAgICAgIGxldCBncm91cFNjb3JlID0gMDtcclxuICAgICAgICBsZXQgZG1nQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCB0aW1lQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBzeW5lcmd5Qm9udXMgPSAwO1xyXG4gICAgICAgIGxldCBiYXNlR3JvdXBTY29yZSA9IDA7XHJcbiAgICAgICAgbGV0IGNhcmRQb3dlckNvdW50ID0gMDtcclxuICAgICAgICBsZXQgZXhwUmV3YXJkQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBycFJld2FyZENvdW50ID0gMDtcclxuICAgICAgICBsZXQgY2FyZFhwQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCB0b2tlblJld2FyZENvdW50ID0gMDtcclxuICAgICAgICBsZXQgdG9rZW5NdWx0ID0gMDtcclxuICAgICAgICBsZXQgdG9rZW5Nb2RpZiA9IDA7XHJcbiAgICAgICAgY29uc3QgdHlwZUNvdW50cyA9IHt9O1xyXG5cclxuICAgICAgICBsZXQgZ3JvdXBTY29yZU1heCA9IDA7XHJcblxyXG4gICAgICAgIGdyb3VwLmZvckVhY2goKHBldCkgPT4ge1xyXG4gICAgICAgICAgICBncm91cFNjb3JlICs9IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShwZXQsIGRlZmF1bHRSYW5rKTtcclxuICAgICAgICAgICAgZ3JvdXBTY29yZU1heCArPSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UocGV0LCAwKTtcclxuICAgICAgICAgICAgaWYgKHBldC5Cb251c0xpc3Quc29tZSgoYm9udXMpID0+IGJvbnVzLklEID09PSAxMDEzKSkge1xyXG4gICAgICAgICAgICAgICAgZG1nQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGV0LkJvbnVzTGlzdC5zb21lKChib251cykgPT4gYm9udXMuSUQgPT09IDEwMTApKSB7XHJcbiAgICAgICAgICAgICAgICBjYXJkUG93ZXJDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwZXQuQm9udXNMaXN0LnNvbWUoKGJvbnVzKSA9PiBib251cy5JRCA9PT0gMTAxMSkpIHtcclxuICAgICAgICAgICAgICAgIGV4cFJld2FyZENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBldC5Cb251c0xpc3Quc29tZSgoYm9udXMpID0+IGJvbnVzLklEID09PSAxMDE0KSkge1xyXG4gICAgICAgICAgICAgICAgY2FyZFhwQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGV0LkJvbnVzTGlzdC5zb21lKChib251cykgPT4gYm9udXMuSUQgPT09IDEwMTIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lQ291bnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGV0LkJvbnVzTGlzdC5zb21lKChib251cykgPT4gYm9udXMuSUQgPT09IDEwMTUpKSB7XHJcbiAgICAgICAgICAgICAgICBycFJld2FyZENvdW50Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBldC5Cb251c0xpc3Quc29tZSgoYm9udXMpID0+IGJvbnVzLklEID09PSAxMDE2KSkge1xyXG4gICAgICAgICAgICAgICAgdG9rZW5SZXdhcmRDb3VudCsrO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb3VudCBwZXQgdHlwZXNcclxuICAgICAgICAgICAgaWYgKHR5cGVDb3VudHNbcGV0LlR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICB0eXBlQ291bnRzW3BldC5UeXBlXSsrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdHlwZUNvdW50c1twZXQuVHlwZV0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwZXQuSUQpIHN5bmVyZ3lCb251cyArPSB0aGlzLlNZTkVSR1lfTU9EX1NURVA7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgYmFzZUdyb3VwU2NvcmUgPSBncm91cFNjb3JlO1xyXG4gICAgICAgIGNvbnN0IFtlYXJ0aFR5cGUsIGFpclR5cGVdID0gT2JqZWN0LnZhbHVlcyh0eXBlQ291bnRzKTtcclxuICAgICAgICBpZiAoZWFydGhUeXBlID4gMCAmJiBhaXJUeXBlID4gMCkgc3luZXJneUJvbnVzICs9IHRoaXMuU1lORVJHWV9NT0RfU1RFUDtcclxuICAgICAgICBpZiAoZWFydGhUeXBlID4gMSAmJiBhaXJUeXBlID4gMSkgc3luZXJneUJvbnVzICs9IHRoaXMuU1lORVJHWV9NT0RfU1RFUDtcclxuXHJcbiAgICAgICAgZ3JvdXBTY29yZSAqPSAoMSArIGRtZ0NvdW50ICogdGhpcy5FWFBfRE1HX01PRCk7XHJcbiAgICAgICAgZ3JvdXBTY29yZU1heCAqPSAoMSArIGRtZ0NvdW50ICogdGhpcy5FWFBfRE1HX01PRCk7XHJcbiAgICAgICAgZ3JvdXBTY29yZSAqPSAoMSArIHRpbWVDb3VudCAqIHRoaXMuRVhQX1RJTUVfTU9EKTtcclxuICAgICAgICBncm91cFNjb3JlTWF4ICo9ICgxICsgdGltZUNvdW50ICogdGhpcy5FWFBfVElNRV9NT0QpO1xyXG4gICAgICAgIGdyb3VwU2NvcmUgKj0gc3luZXJneUJvbnVzO1xyXG4gICAgICAgIGdyb3VwU2NvcmVNYXggKj0gc3luZXJneUJvbnVzO1xyXG5cclxuICAgICAgICB0b2tlbk1vZGlmID0gdG9rZW5SZXdhcmRDb3VudCAqIHRoaXMuRVhQX1RPS0VOX01PRDtcclxuICAgICAgICB0b2tlbk11bHQgPSBzeW5lcmd5Qm9udXMgKyBzeW5lcmd5Qm9udXMgKiB0b2tlbk1vZGlmO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGdyb3VwU2NvcmUsXHJcbiAgICAgICAgICAgIGJhc2VHcm91cFNjb3JlLFxyXG4gICAgICAgICAgICBncm91cFNjb3JlTWF4LFxyXG4gICAgICAgICAgICBkbWdDb3VudCxcclxuICAgICAgICAgICAgdGltZUNvdW50LFxyXG4gICAgICAgICAgICBzeW5lcmd5Qm9udXMsXHJcbiAgICAgICAgICAgIGNhcmRQb3dlckNvdW50LFxyXG4gICAgICAgICAgICBleHBSZXdhcmRDb3VudCxcclxuICAgICAgICAgICAgY2FyZFhwQ291bnQsXHJcbiAgICAgICAgICAgIHJwUmV3YXJkQ291bnQsXHJcbiAgICAgICAgICAgIHRva2VuUmV3YXJkQ291bnQsXHJcbiAgICAgICAgICAgIHRva2VuTW9kaWYsXHJcbiAgICAgICAgICAgIHRva2VuTXVsdFxyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgZ2V0QmVzdERhbWFnZVBldHM6IGZ1bmN0aW9uIChwZXRzQ29sbGVjdGlvbiwgZGVmYXVsdFJhbmssIG90aGVyKSB7XHJcbiAgICAgICAgbGV0IGZpbmFsQ29sbGVjdGlvbiA9IHt9O1xyXG4gICAgICAgIGxldCBiZXN0RGFtYWdlUGV0cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGV0c0NvbGxlY3Rpb24pKTtcclxuXHJcbiAgICAgICAgLy9BcyByZXF1aXJlZCArIG1pc2NlbGxlbmFvdXMgcGV0cyBhcmUgYWRkZWQsIGtlZXAgdHJhY2sgb2YgdG9wIDQgc3Ryb25nZXN0IC0+IHRvIHByZXZlbnQgYWRkaW5nIG5vbi1zcGVjaWFsIHdlYWsgcGV0c1xyXG4gICAgICAgIC8vVGhpcyByZWFsbHkgaW5pdGlhbGx5IG9ubHkgc3RvcmVzIHJlcXVpcmVkLCBleHAgZG1nLCBleHAgdGltZSBib251cyBwZXRzXHJcbiAgICAgICAgbGV0IHN0cm9uZ2VzdEduZCA9IFtdO1xyXG4gICAgICAgIGxldCBzdHJvbmdlc3RBaXIgPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3QgdXBkYXRlU3Ryb25nZXN0ID0gKHBldCkgPT4ge1xyXG4gICAgICAgICAgICAvL0dyb3VuZFxyXG4gICAgICAgICAgICBpZiAocGV0LlR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgIC8vTm8gcGV0cyB5ZXQsIGp1c3QgYWRkIGl0XHJcbiAgICAgICAgICAgICAgICBpZiAoc3Ryb25nZXN0R25kLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEduZC5wdXNoKHBldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0lmIHRoZXJlIGlzIDEsIGNoZWNrIGlmIG5ldyBpcyBzdHJvbmdlciB0aGFuIGluaXRpYWwgKGlmIHllcywgbWFrZSAjMSAtPiAjMiwgdGhlbiBhZGQgbmV3IHRvICMxKSwgZWxzZSBhZGQgaXQgIzJcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cm9uZ2VzdEduZC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKHN0cm9uZ2VzdEduZFswXSwgZGVmYXVsdFJhbmspIDwgdGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKHBldCwgZGVmYXVsdFJhbmspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEduZFsxXSA9IHN0cm9uZ2VzdEduZFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb25nZXN0R25kWzBdID0gcGV0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb25nZXN0R25kWzFdID0gcGV0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgaWYgaXQgaXMgc3Ryb25nZXIgdGhhbiBzdHJvbmdlc3RcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShzdHJvbmdlc3RHbmRbMF0sIGRlZmF1bHRSYW5rKSA8IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShwZXQsIGRlZmF1bHRSYW5rKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEduZFsxXSA9IHN0cm9uZ2VzdEduZFswXTtcclxuICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RHbmRbMF0gPSBwZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIGl0IGlzIHN0cm9uZ2VyIHRoYW4gd2Vha2VzdFxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKHN0cm9uZ2VzdEduZFsxXSwgZGVmYXVsdFJhbmspIDwgdGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKHBldCwgZGVmYXVsdFJhbmspKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb25nZXN0R25kWzFdID0gcGV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vQWlyXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBldC5UeXBlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAvL05vIHBldHMgeWV0LCBqdXN0IGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9uZ2VzdEFpci5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RBaXIucHVzaChwZXQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9JZiB0aGVyZSBpcyAxLCBjaGVjayBpZiBuZXcgaXMgc3Ryb25nZXIgdGhhbiBpbml0aWFsIChpZiB5ZXMsIG1ha2UgIzEgLT4gIzIsIHRoZW4gYWRkIG5ldyB0byAjMSksIGVsc2UgYWRkIGl0ICMyXHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdHJvbmdlc3RBaXIubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShzdHJvbmdlc3RBaXJbMF0sIGRlZmF1bHRSYW5rKSA8IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShwZXQsIGRlZmF1bHRSYW5rKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RBaXJbMV0gPSBzdHJvbmdlc3RBaXJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEFpclswXSA9IHBldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEFpclsxXSA9IHBldDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIGl0IGlzIHN0cm9uZ2VyIHRoYW4gc3Ryb25nZXN0XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2Uoc3Ryb25nZXN0QWlyWzBdLCBkZWZhdWx0UmFuaykgPCB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UocGV0LCBkZWZhdWx0UmFuaykpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RBaXJbMV0gPSBzdHJvbmdlc3RBaXJbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgc3Ryb25nZXN0QWlyWzBdID0gcGV0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9DaGVjayBpZiBpdCBpcyBzdHJvbmdlciB0aGFuIHdlYWtlc3RcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShzdHJvbmdlc3RBaXJbMV0sIGRlZmF1bHRSYW5rKSA8IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShwZXQsIGRlZmF1bHRSYW5rKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEFpclsxXSA9IHBldDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGRtZ09ubHlQZXRzID0gW107XHJcbiAgICAgICAgbGV0IHJlcXVpcmVkUGV0cyA9IHt9O1xyXG4gICAgICAgIGxldCBhaXJEbWdPbmx5Q291bnQgPSAwO1xyXG4gICAgICAgIGxldCBnbmREbWdPbmx5Q291bnQgPSAwO1xyXG4gICAgICAgIGlmIChvdGhlcilcclxuICAgICAgICAgICAgaWYgKG90aGVyLnJlcXVpcmVkUGV0cykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlci5yZXF1aXJlZFBldHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldHNbb3RoZXIucmVxdWlyZWRQZXRzW2ldLklEXSA9IG90aGVyLnJlcXVpcmVkUGV0c1tpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmVzdERhbWFnZVBldHMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgIGxldCBjdXIgPSBiZXN0RGFtYWdlUGV0c1tpXTtcclxuICAgICAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY3VyLkJvbnVzTGlzdC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvbnVzID0gY3VyLkJvbnVzTGlzdFtqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL0FkZCBhbnkgcmVxdWlyZWQgcGV0cyB0byB0aGUgbGlzdFxyXG4gICAgICAgICAgICAgICAgaWYgKGN1ci5JRCBpbiByZXF1aXJlZFBldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5hbENvbGxlY3Rpb25bY3VyLklEXSA9IGN1cjtcclxuICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvL0RuZyBkbWcgYm9udXNcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvbnVzLklEID09PSAxMDEzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaW5hbENvbGxlY3Rpb25bY3VyLklEXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbENvbGxlY3Rpb25bY3VyLklEXSA9IGN1cjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vRG5nIHRpbWUgYm9udXNcclxuICAgICAgICAgICAgICAgIGlmIChib251cy5JRCA9PT0gMTAxMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghZmluYWxDb2xsZWN0aW9uW2N1ci5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxDb2xsZWN0aW9uW2N1ci5JRF0gPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFhZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgZG1nT25seVBldHMucHVzaChjdXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1ci5UeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ25kRG1nT25seUNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhaXJEbWdPbmx5Q291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL1NpbmNlIGl0IHdhcyBhZGRlZCwgdXBkYXRlIHN0cm9uZ2VzdCBsaXN0XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlU3Ryb25nZXN0KGN1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IHNwZWNpYWxBaXIgPSBzdHJvbmdlc3RBaXIubGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHNwZWNpYWxHbmQgPSBzdHJvbmdlc3RHbmQubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzcGVjaWFsUGV0cyA9IHN0cm9uZ2VzdEFpci5jb25jYXQoc3Ryb25nZXN0R25kKTtcclxuXHJcbiAgICAgICAgLy9BZGQgYWxsIHRoZSBzcGVjaWFsIHBldHMgdG8gdGhlIHJlcXVpcmVkIGxpc3RcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWNpYWxQZXRzOyBpKyspIHtcclxuICAgICAgICAgICAgZmluYWxDb2xsZWN0aW9uW3BldC5JRF0gPSBzcGVjaWFsUGV0c1tpXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vSG93IG1hbnkgbW9yZSBwZXRzIG9mIGVhY2ggdHlwZSBJIG5lZWQgdG8gZmluZCBzdGlsbCAoaS5lLiBpZiBJIGhhdmUgYSB0b3RhbCBvZiAxIGFpciBwZXRzLCB0aGVuIGkgbmVlZCAzIGdyb3VuZClcclxuICAgICAgICBsZXQgZXh0cmFHbmQgPSAyO1xyXG4gICAgICAgIGxldCBleHRyYUFpciA9IDI7XHJcblxyXG4gICAgICAgIGlmICgoc3BlY2lhbEduZCArIGduZERtZ09ubHlDb3VudCkgPCAyKSB7XHJcbiAgICAgICAgICAgIGV4dHJhQWlyICs9IDIgLSAoc3BlY2lhbEduZCArIGduZERtZ09ubHlDb3VudClcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChzcGVjaWFsQWlyICsgYWlyRG1nT25seUNvdW50KSA8IDIpIHtcclxuICAgICAgICAgICAgZXh0cmFHbmQgKz0gMiAtIChzcGVjaWFsQWlyICsgYWlyRG1nT25seUNvdW50KVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGxldCBzb3J0R25kID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IHNvcnRBaXIgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgLy9HbyBvdmVyIHJlbWFpbmluZyBwdXJlIGRtZyBwZXRzLCBhbmQgZmluZCB0aGUgdG9wIDQgKHByZWZlcmFibGUgMmduZCBhbmQgMmFpciB0byBwdXQgaW4gdG8gY29uc2lkZXIgdG9nZXRoZXIgd2l0aCBzcGVjaWFsIHBldHMpXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkbWdPbmx5UGV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgcGV0ID0gZG1nT25seVBldHNbaV07XHJcbiAgICAgICAgICAgIGxldCBkbWcgPSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UocGV0LCBkZWZhdWx0UmFuayk7XHJcblxyXG4gICAgICAgICAgICBpZiAocGV0LlR5cGUgPT09IDEpIHsvL0dyb3VuZCBwZXRcclxuICAgICAgICAgICAgICAgIGlmIChzdHJvbmdlc3RHbmQubGVuZ3RoIDwgZXh0cmFHbmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RHbmQucHVzaChwZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNvcnRHbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdHJvbmdlc3RHbmQubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyUGV0ID0gc3Ryb25nZXN0R25kW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXJEbWcgPSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoaW5uZXJQZXQsIGRlZmF1bHRSYW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRtZyA+IGlubmVyRG1nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RHbmRbal0gPSBwZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0R25kID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Ugey8vQWlyIHBldFxyXG4gICAgICAgICAgICAgICAgaWYgKHN0cm9uZ2VzdEFpci5sZW5ndGggPCBleHRyYUFpcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEFpci5wdXNoKHBldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydEFpciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0cm9uZ2VzdEFpci5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXJQZXQgPSBzdHJvbmdlc3RBaXJbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lckRtZyA9IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShpbm5lclBldCwgZGVmYXVsdFJhbmspO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG1nID4gaW5uZXJEbWcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEFpcltqXSA9IHBldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRBaXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvL01ha2Ugc3VyZSB0byBzb3J0IGluIHJldmVyc2Ugb3JkZXIhISBiZWNhdXNlIGkgcmVwbGFjZSB0aGUgZmlyc3QgcGV0IEkgYmVhdCAod2hpY2ggbmVlZHMgdG8gYmUgdGhlIHdlYWtlc3Qgb25lKVxyXG4gICAgICAgICAgICBpZiAoc29ydEduZCkge1xyXG4gICAgICAgICAgICAgICAgc29ydEduZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3Ryb25nZXN0R25kLnNvcnQoKGEsIGIpID0+IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShhLCBkZWZhdWx0UmFuaykgLSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYiwgZGVmYXVsdFJhbmspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc29ydEFpcikge1xyXG4gICAgICAgICAgICAgICAgc29ydEFpciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc3Ryb25nZXN0QWlyLnNvcnQoKGEsIGIpID0+IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShhLCBkZWZhdWx0UmFuaykgLSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYiwgZGVmYXVsdFJhbmspKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9NYWtlIHRoZSB1cGRhdGVkIGxpc3QgYW5kIGFkZCBpdCBhbGwgaW4sIGR1cGxpY2F0ZXMgd2lsbCBqdXN0IG92ZXJ3cml0ZSB0aGVtc2VsdmVzIHNvIGl0cyBmaW5lXHJcbiAgICAgICAgc3BlY2lhbFBldHMgPSBzdHJvbmdlc3RBaXIuY29uY2F0KHN0cm9uZ2VzdEduZCk7XHJcblxyXG4gICAgICAgIC8vQWRkIGFsbCB0aGUgc3BlY2lhbCBwZXRzIHRvIHRoZSByZXF1aXJlZCBsaXN0XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGVjaWFsUGV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBmaW5hbENvbGxlY3Rpb25bc3BlY2lhbFBldHNbaV0uSURdID0gc3BlY2lhbFBldHNbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZmluYWxQZXRzQ29sbGVjdGlvbiA9IE9iamVjdC52YWx1ZXMoZmluYWxDb2xsZWN0aW9uKTtcclxuICAgICAgICBmaW5hbFBldHNDb2xsZWN0aW9uLnNvcnQoKGEsIGIpID0+IGIuSUQgLSBhLklEKTtcclxuICAgICAgICByZXR1cm4gZmluYWxQZXRzQ29sbGVjdGlvbjtcclxuXHJcblxyXG4gICAgICAgIC8vIC8vU29ydCByZW1haW5pbmdcclxuICAgICAgICAvLyBkbWdPbmx5UGV0cy5zb3J0KChhLCBiKSA9PiB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYiwgZGVmYXVsdFJhbmspIC0gdGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKGEsIGRlZmF1bHRSYW5rKSk7XHJcblxyXG5cclxuICAgICAgICAvLyBsZXQgYWlyVG90YWwgPSAwO1xyXG4gICAgICAgIC8vIGxldCBncm91bmRUb3RhbCA9IDA7XHJcbiAgICAgICAgLy8gZG1nT25seVBldHMubWFwKChjdXJyKSA9PiB7XHJcbiAgICAgICAgLy8gICAgIGlmIChjdXJyLlR5cGUgPT09IDEpIGdyb3VuZFRvdGFsKys7XHJcbiAgICAgICAgLy8gICAgIGlmIChjdXJyLlR5cGUgPT09IDIpIGFpclRvdGFsKys7XHJcbiAgICAgICAgLy8gfSlcclxuXHJcblxyXG5cclxuICAgICAgICAvLyBsZXQgZ3JvdW5kID0gMDsvL3R5cGUgMVxyXG4gICAgICAgIC8vIGxldCBhaXIgPSAwOyAvL3R5cGUgMlxyXG4gICAgICAgIC8vIGxldCBjb3VudGVyID0gMDtcclxuXHJcbiAgICAgICAgLy8gaWYgKGdyb3VuZFRvdGFsIDwgMikge1xyXG4gICAgICAgIC8vICAgICBsZXQgZ3JvdW5kID0gW107XHJcbiAgICAgICAgLy8gICAgIGdyb3VuZFRvdGFsID0gMDtcclxuICAgICAgICAvLyAgICAgZG1nT25seVBldHMubWFwKChjdXIpID0+IHtcclxuICAgICAgICAvLyAgICAgICAgIGlmIChjdXIuVHlwZSA9PT0gMSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGdyb3VuZC5wdXNoKGN1cik7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZmluYWxDb2xsZWN0aW9uW2N1ci5JRF0gPSBjdXI7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgZG1nT25seVBldHMgPSBkbWdPbmx5UGV0cy5maWx0ZXIoKGN1cnJlbnQpID0+IHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQuSUQgIT09IGN1ci5JRFxyXG4gICAgICAgIC8vICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgIH0pO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZiAoYWlyVG90YWwgPCAyKSB7XHJcbiAgICAgICAgLy8gICAgIGxldCBhaXIgPSBbXTtcclxuICAgICAgICAvLyAgICAgYWlyVG90YWwgPSAwO1xyXG4gICAgICAgIC8vICAgICBkbWdPbmx5UGV0cy5tYXAoKGN1cikgPT4ge1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKGN1ci5UeXBlID09PSAyKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgYWlyLnB1c2goY3VyKTtcclxuICAgICAgICAvLyAgICAgICAgICAgICBmaW5hbENvbGxlY3Rpb25bY3VyLklEXSA9IGN1cjtcclxuICAgICAgICAvLyAgICAgICAgICAgICBkbWdPbmx5UGV0cyA9IGRtZ09ubHlQZXRzLmZpbHRlcigoY3VycmVudCkgPT4ge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudC5JRCAhPT0gY3VyLklEXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfSlcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgfSk7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuXHJcbiAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCBkbWdPbmx5UGV0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vICAgICBsZXQgY3VyID0gZG1nT25seVBldHNbaV07XHJcblxyXG4gICAgICAgIC8vICAgICBpZiAoZ3JvdW5kIDwgMiAmJiBjdXIuVHlwZSA9PT0gMSB8fCBhaXJUb3RhbCA8PSAwKSB7XHJcblxyXG5cclxuICAgICAgICAvLyAgICAgICAgIC8vQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgY3VycmVudCBwZXQsIG9yIHRoZSBzdHJvbmdlc3RHbmQgYXJlIHN0cm9uZyBlbm91Z2hcclxuICAgICAgICAvLyAgICAgICAgIGlmIChzdHJvbmdlc3RHbmQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGxldCBqID0gMDtcclxuICAgICAgICAvLyAgICAgICAgICAgICB3aGlsZSAoc3Ryb25nZXN0R25kLmxlbmd0aCA+IDAgJiYgaiA8PSBzdHJvbmdlc3RHbmQubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGxldCBzdG5nID0gc3Ryb25nZXN0R25kW2pdO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBpZiAoc3RuZykge1xyXG5cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2Uoc3RuZywgZGVmYXVsdFJhbmspID49IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShjdXIsIGRlZmF1bHRSYW5rKSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9uZ2VzdEduZC5zcGxpY2UoaiwgMSk7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxDb2xsZWN0aW9uW2N1ci5JRF0gPSBjdXI7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdW5kKys7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgY291bnRlcisrO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBqKys7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAgICAgICAgIC8vUG90ZW50aWFsbHkgMiBzdHJvbmdlc3QgYXJlIGJldHRlciB0aGFuIGN1cnJlbnQsIHNvIGRvbid0IGFkZCBpdCBpZiB3ZSBhZGRlZCB0aGUgb3RoZXIgMiwgb3IgaWYgdGhlcmUgYXJlIG5vIGFpciBhbmQgY291bnRlciBsZXNzIHRoYW4gM1xyXG4gICAgICAgIC8vICAgICAgICAgaWYgKGdyb3VuZCA8IDIgfHwgKGNvdW50ZXIgPCA0ICYmIGFpclRvdGFsIDw9IDApKSB7XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgICAgIGZpbmFsQ29sbGVjdGlvbltjdXIuSURdID0gY3VyO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGdyb3VuZCsrO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAvLyAgICAgICAgICAgICBncm91bmRUb3RhbC0tO1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICB9XHJcblxyXG4gICAgICAgIC8vICAgICBlbHNlIGlmIChhaXIgPCAyICYmIGN1ci5UeXBlID09PSAyIHx8IGdyb3VuZFRvdGFsIDw9IDApIHtcclxuXHJcbiAgICAgICAgLy8gICAgICAgICAvL0NoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGN1cnJlbnQgcGV0LCBvciB0aGUgc3Ryb25nZXN0R25kIGFyZSBzdHJvbmcgZW5vdWdoXHJcbiAgICAgICAgLy8gICAgICAgICBpZiAoc3Ryb25nZXN0QWlyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICBsZXQgaiA9IDA7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgd2hpbGUgKHN0cm9uZ2VzdEFpci5sZW5ndGggPiAwICYmIGogPD0gc3Ryb25nZXN0QWlyLmxlbmd0aCkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICBsZXQgc3RuZyA9IHN0cm9uZ2VzdEFpcltqXTtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaWYgKHN0bmcpIHtcclxuXHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKHN0bmcsIGRlZmF1bHRSYW5rKSA+PSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoY3VyLCBkZWZhdWx0UmFuaykpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBzdHJvbmdlc3RBaXIuc3BsaWNlKGosIDEpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsQ29sbGVjdGlvbltjdXIuSURdID0gY3VyO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGFpcisrO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICBqLS07XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgaisrO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gICAgICAgICAvL1BvdGVudGlhbGx5IDIgc3Ryb25nZXN0IGFyZSBiZXR0ZXIgdGhhbiBjdXJyZW50LCBzbyBkb24ndCBhZGQgaXQgaWYgd2UgYWRkZWQgdGhlIG90aGVyIDIsIG9yIGlmIHRoZXJlIGFyZSBubyBhaXIgYW5kIGNvdW50ZXIgbGVzcyB0aGFuIDNcclxuICAgICAgICAvLyAgICAgICAgIGlmIChhaXIgPCAyIHx8IChjb3VudGVyIDwgNCAmJiBncm91bmRUb3RhbCA8PSAwKSkge1xyXG5cclxuICAgICAgICAvLyAgICAgICAgICAgICBmaW5hbENvbGxlY3Rpb25bY3VyLklEXSA9IGN1cjtcclxuICAgICAgICAvLyAgICAgICAgICAgICBhaXIrKztcclxuICAgICAgICAvLyAgICAgICAgICAgICBjb3VudGVyKytcclxuICAgICAgICAvLyAgICAgICAgICAgICBhaXJUb3RhbC0tO1xyXG4gICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGlmIChjb3VudGVyID4gMykgYnJlYWs7XHJcbiAgICAgICAgLy8gfVxyXG5cclxuICAgICAgICAvLyBsZXQgZmluYWxQZXRzQ29sbGVjdGlvbiA9IE9iamVjdC52YWx1ZXMoZmluYWxDb2xsZWN0aW9uKTtcclxuICAgICAgICAvLyBmaW5hbFBldHNDb2xsZWN0aW9uLnNvcnQoKGEsIGIpID0+IGIuSUQgLSBhLklEKTtcclxuICAgICAgICAvLyByZXR1cm4gZmluYWxQZXRzQ29sbGVjdGlvbjtcclxuICAgIH0sXHJcbiAgICBjYWxjQmVzdERhbWFnZUdyb3VwOiBmdW5jdGlvbiAoUEVUU0NPTExFQ1RJT04sIGRlZmF1bHRSYW5rLCBudW1Hcm91cHMsIG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgayA9IDQ7IC8vIFNpemUgb2YgZWFjaCBncm91cFxyXG4gICAgICAgIG51bUdyb3VwcyA9IG51bUdyb3VwcyA/IG51bUdyb3VwcyA6IDc7XHJcbiAgICAgICAgbnVtR3JvdXBzID0gTnVtYmVyKG51bUdyb3Vwcyk7XHJcbiAgICAgICAgY29uc3QgbWVtbyA9IHt9O1xyXG4gICAgICAgIGxldCBmYWlsZWRGaWx0ZXJzT2JqID0ge307XHJcbiAgICAgICAgbGV0IHBldHNNYXAgPSB7fTtcclxuXHJcbiAgICAgICAgb3RoZXIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG90aGVyKSk7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUEVUU0NPTExFQ1RJT04ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcGV0c01hcFtQRVRTQ09MTEVDVElPTltpXS5JRF0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KFBFVFNDT0xMRUNUSU9OW2ldKSlcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBhY3RpdmVCb251c2VzID0gb3RoZXI/LmFjdGl2ZUJvbnVzZXM7XHJcbiAgICAgICAgaWYgKCFhY3RpdmVCb251c2VzKSBhY3RpdmVCb251c2VzID0gW107XHJcblxyXG4gICAgICAgIGNvbnN0IG1lbW9pemVkR3JvdXBTY29yZSA9IChncm91cCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBncm91cC5JRDtcclxuICAgICAgICAgICAgaWYgKCFtZW1vW2tleV0gfHwgbWVtb1trZXldKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVzID0gdGhpcy5jYWxjdWxhdGVHcm91cFNjb3JlKGdyb3VwLnRlYW0sIGRlZmF1bHRSYW5rKTtcclxuICAgICAgICAgICAgICAgIGxldCBzdW0gPSByZXMudG9rZW5NdWx0O1xyXG4gICAgICAgICAgICAgICAgbWVtb1trZXldID0geyB0b2tlbjogc3VtLCBkYW1hZ2U6IHJlcy5ncm91cFNjb3JlLCBvdGhlcjogcmVzIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lbW9ba2V5XTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBsZXQgYmxhY2tMaXN0ID0ge307XHJcbiAgICAgICAgbGV0IHdoaXRlbGlzdCA9IHt9O1xyXG4gICAgICAgIGxldCB3aGl0ZWxpc3RSZWwgPSB7fTtcclxuXHJcbiAgICAgICAgbGV0IGxvY2tlZFBldHMgPSB7fTtcclxuICAgICAgICBsZXQgYXV0b1BldHMgPSB7fTtcclxuICAgICAgICBsZXQgcHN1ZWRvR3JvdXBzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Hcm91cHM7IGkrKykge1xyXG4gICAgICAgICAgICBwc3VlZG9Hcm91cHMucHVzaChbXSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3RoZXI/LnBldFdoaXRlTGlzdCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG90aGVyLnBldFdoaXRlTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGN1ciA9IG90aGVyLnBldFdoaXRlTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChjdXIucGxhY2VtZW50ID09PSAnYmxhY2tsaXN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsYWNrTGlzdFtjdXIuaWRdID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnBsYWNlbWVudCA9PT0gJ3RlYW0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVsaXN0W2N1ci5pZF0gPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgbG9ja2VkUGV0c1tjdXIuaWRdID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgIHBzdWVkb0dyb3Vwc1tjdXIucGFyYW1ldGVycy50ZWFtXS5wdXNoKGN1cik7XHJcblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnBsYWNlbWVudCA9PT0gJ3JlbCcpIHtcclxuICAgICAgICAgICAgICAgICAgICB3aGl0ZWxpc3RSZWxbY3VyLmlkXSA9IGN1cjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9HbyBvdmVyIGFueSBgYXV0byBwbGFjZW1lbnRzIGFuZCBzbG90IHRoZW0gaW4gaW4gYSBwc2V1ZG8gbWFubmVyXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3RoZXIucGV0V2hpdGVMaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3VyID0gb3RoZXIucGV0V2hpdGVMaXN0W2ldO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChjdXIucGxhY2VtZW50ID09PSAnYXV0bycpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYmlnc2FkID0gLTE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBudW1Hcm91cHMgLSAxOyBqID49IDA7IGotLSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG51bUduZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBudW1BaXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcHN1ZWRvR3JvdXBzW2pdLmZvckVhY2goKGlubmVyX3BldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyX3BldC5wZXQuVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUduZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyX3BldC5wZXQuVHlwZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUFpcisrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5wZXQuVHlwZSA9PT0gMSAmJiBudW1HbmQgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLnBldC5UeXBlID09PSAyICYmIG51bUFpciA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHN1ZWRvR3JvdXBzW2pdLmxlbmd0aCA8IGspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5hdXRvID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ci5wYXJhbWV0ZXJzLnRlYW0gPSBqO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyLnBsYWNlbWVudCA9ICd0ZWFtJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlbGlzdFtjdXIuaWRdID0gY3VyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHN1ZWRvR3JvdXBzW2pdLnB1c2goY3VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dG9QZXRzW2N1ci5pZF0gPSBjdXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGdldENvbWJpbmF0aW9uc0lubmVyID0gKGFycmF5LCBrLCBib251c0xpc3QpID0+IHtcclxuXHJcbiAgICAgICAgICAgIC8vIGxldCB0ZW1wID0gW107XHJcbiAgICAgICAgICAgIGxldCBiZXN0ID0gLTE7XHJcblxyXG4gICAgICAgICAgICAvL2NvbmZpcm0gdGhlcmUgaXMgZW5vdWdoIGduZC9haXIgZm9yIHBlcmZlY3Qgc3luZXJneVxyXG4gICAgICAgICAgICBsZXQgYWlyVGVtcCA9IDA7XHJcbiAgICAgICAgICAgIGxldCBncm91bmRUZW1wID0gMDtcclxuXHJcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLlR5cGUgPT09IDEpIGdyb3VuZFRlbXArKztcclxuICAgICAgICAgICAgICAgIGVsc2UgYWlyVGVtcCsrO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGxldCBiYWRfc3luZXJneV9hbGxvd2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGFpclRlbXAgPiAxICYmIGdyb3VuZFRlbXAgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBiYWRfc3luZXJneV9hbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAvL051bWJlciBvZiBhaXIvZ25kIHBldHMgdGhhdCBhcmUgbWFudWFsbHkgcGxhY2VkIC0+IGRlZmF1bHQgYWxsb3cgYmFkIHN5bmVyZ3lcclxuICAgICAgICAgICAgbGV0IHJlcXVpcmVkQWlyID0ge307XHJcbiAgICAgICAgICAgIGxldCByZXF1aXJlZEduZCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgLy9DaGVjayBudW0gYWlyIGFuZCBudW0gZ3JvdW5kIHJlbGF0aXZlIHBldHMgZnJvbSBib251c1xyXG4gICAgICAgICAgICBsZXQgcmVsQWlyVG90YWxNYXAgPSB7fTtcclxuICAgICAgICAgICAgbGV0IHJlbEduZFRvdGFsTWFwID0ge307XHJcblxyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib251c0xpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGxldCBib251cyA9IGJvbnVzTGlzdFtpXTtcclxuICAgICAgICAgICAgICAgIGlmIChib251cy5wbGFjZW1lbnQgPT09ICd0ZWFtJykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWJvbnVzLnBhcmFtZXRlcnMuZmFrZSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvbnVzLnBldC5UeXBlID09PSAxICYmICFyZXF1aXJlZEduZFtib251cy5wZXQuSURdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEduZFtib251cy5wZXQuSURdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVxdWlyZWRHbmRbYm9udXMucGV0LklEXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRBaXJbYm9udXMucGV0LklEXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlnc2FkID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib251cy5wZXQuVHlwZSA9PT0gMiAmJiAhcmVsQWlyVG90YWxNYXBbYm9udXMucGV0LklEXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsQWlyVG90YWxNYXBbYm9udXMucGV0LklEXSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXJlbEduZFRvdGFsTWFwW2JvbnVzLnBldC5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbEduZFRvdGFsTWFwW2JvbnVzLnBldC5JRF0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSAoc3RhcnQsIHByZXZDb21iaW5hdGlvbikgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q29tYmluYXRpb24ubGVuZ3RoID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsaWRUZWFtID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFrZVJlbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4YWN0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhQZXRzID0gNDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9DaGVjayBob3cgbWFueSBwZXRzIG9mIGVhY2ggdHlwZSBhcmUgdGhlIGNvcnJlY3QgcmVsIG9uZXNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckFpciA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJHbmQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2Fic29sdXRlIG51bWJlciBvZiBlYWNoIHR5cGUgb2YgcGV0XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvdGFsR25kID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxBaXIgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXB5ID0gcHJldkNvbWJpbmF0aW9uW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcHkuVHlwZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxHbmQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsQWlyKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXB5LlR5cGUgPT09IDEgJiYgcmVsR25kVG90YWxNYXBbdGVtcHkuSURdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyR25kKytcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWxBaXJUb3RhbE1hcFt0ZW1weS5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBaXIrK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcUFpciA9IE9iamVjdC5lbnRyaWVzKHJlcXVpcmVkQWlyKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcUduZCA9IE9iamVjdC5lbnRyaWVzKHJlcXVpcmVkR25kKS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlbEFpclRvdGFsID0gT2JqZWN0LmVudHJpZXMocmVsQWlyVG90YWxNYXApLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVsR25kVG90YWwgPSBPYmplY3QuZW50cmllcyhyZWxHbmRUb3RhbE1hcCkubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0RldGVybWluZSBob3cgbWFueSBtb3JlIGByZWxgIG9mIGduZC9mbHkgdHlwZSBhcmUgYWxsb3dlZCBiYXNlZCBvbiBob3cgbWFueSBoYXJkIChwbGFjZW1lbnQ9Z3JvdXApIHRoZXJlIGFyZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhaXJMaW1pdCA9IDIgPiByZXFBaXIgPyAyIC0gcmVxQWlyIDogMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZ25kTGltaXQgPSAyID4gcmVxR25kID8gMiAtIHJlcUduZCA6IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXhSZWwgPSAwO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9JIGNhbiBoYXZlIGEgbWF4IG9mIDIgYWlyIG9yIDIgZ3JvdW5kXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaSBoYXZlIGFueSByZXF1aXJlZCBhaXIsIG51bWJlciBvZiByZWxhdGl2ZSBhaXIgYWxsb3dlZCBpcyAyIC0gcmVxdWlyZWRcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBudW0gcmVsYXRpdmUgYWlyID4gMCBJIG5lZWQgdG8gbWFrZSBzdXJlIGkgaGF2ZSBhIGFuIGFpciwgYnV0IGxlc3MgdGhlbiB0aGUgbnVtYmVyIGFib3ZlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlcmUgYXJlIGFueSByZWxhdGl2ZSBhaXIgcGV0cyByZXF1aXJlZFxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxBaXJUb3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoZWNrTnVtID0gcmVsQWlyVG90YWwgPCBhaXJMaW1pdCA/IHJlbEFpclRvdGFsIDogYWlyTGltaXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckFpciA+IGFpckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFRlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQWlyICE9PSBjaGVja051bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUZWFtID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZWwgKz0gY2hlY2tOdW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbEduZFRvdGFsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2hlY2tOdW0gPSByZWxHbmRUb3RhbCA8IGduZExpbWl0ID8gcmVsR25kVG90YWwgOiBnbmRMaW1pdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyR25kID4gZ25kTGltaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVGVhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1cnJHbmQgIT09IGNoZWNrTnVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFRlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFJlbCArPSBjaGVja051bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFpck1heEluY3JlYXNlID0gcmVxQWlyID4gMiA/IHJlcUFpciAtIDIgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBnbmRNYXhJbmNyZWFzZSA9IHJlcUduZCA+IDIgPyByZXFHbmQgLSAyIDogMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0b3RhbEFpciA+ICgyICsgYWlyTWF4SW5jcmVhc2UpIHx8IHRvdGFsR25kID4gKDIgKyBnbmRNYXhJbmNyZWFzZSkpICYmICFiYWRfc3luZXJneV9hbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVGVhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbEFpclRvdGFsID4gMCB8fCByZWxHbmRUb3RhbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ3NhZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZFRlYW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib251c0xpc3QubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ3NhZCA9IC0xO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRmlyc3QgY29uZmlybSB0aGUgdGhlIGNvbWJpbmF0aW9uIHNhdGlzZmllcyBhbGwgYm9udXNlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvbnVzTGlzdC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvbnVzID0gYm9udXNMaXN0W2ldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBhc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1BldCBiZWluZyBmb3JjZWZ1bGwgaW5jbHVkZWQsIG5lZWRzIHRvIGJlIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib251cy5wbGFjZW1lbnQgPT09ICd0ZWFtJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyQ291bnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcHJldkNvbWJpbmF0aW9uLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwZXQgPSBwcmV2Q29tYmluYXRpb25bal07XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBldC5JRCA9PT0gYm9udXMucGV0LklEKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9GYWtlIG1lYW5zIGl0cyBhIHJlbCBwZXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib251cy5wYXJhbWV0ZXJzLmZha2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIHdlIGhhdmUgdG9vIG1hbnkgYWlyL2duZCBwZXRzIGJlZm9yZSBhZGRpbmcgdGhpcyBvbmUgaW5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHBldC5UeXBlID09PSAxICYmIGN1cnJHbmQgPiBnbmRMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiAoY3VyckFpciA+IGFpckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFrZVJlbCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3QrKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBldC5UeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcUduZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxQWlyKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGB3ZSBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYm9udXMucGFyYW1ldGVycy5mYWtlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGB3ZSBub3QgZ29vZGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFRlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01lYW5pbmcgdGhlcmUgYXJlIHJlcXVpcmVkIHBldHMgdGhhdCBoYXZlIHRvIGJlIGluIHRoZSBjb21wXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib251cy5yZXF1aXJlZE51bWJlciA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBldCA9IHByZXZDb21iaW5hdGlvbltqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXQuQm9udXNMaXN0LmZpbmQoKGEpID0+IGEuSUQgPT09IGJvbnVzLmJvbnVzLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckNvdW50ID49IGJvbnVzLnJlcXVpcmVkTnVtYmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGB3ZSBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHdlIG5vdCBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVGVhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGJvbnVzLmV4YWN0TnVtYmVyID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBldCA9IHByZXZDb21iaW5hdGlvbltqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZXQuQm9udXNMaXN0LmZpbmQoKGEpID0+IGEuSUQgPT09IGJvbnVzLmJvbnVzLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvdW50Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyckNvdW50ID09PSBib251cy5leGFjdE51bWJlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgd2UgZ29vZGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGB3ZSBub3QgZ29vZGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFRlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01lYW5pbmcgdGhlcmUgaXMgYSBgcmVsYCBmaWx0ZXIgYWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChib251cy5ib251cy5wbGFjZW1lbnQgPT09ICdyZWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJDb3VudCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heENvdW50ZXIgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHByZXZDb21iaW5hdGlvbi5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGV0ID0gcHJldkNvbWJpbmF0aW9uW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGV0LkJvbnVzTGlzdC5maW5kKChhKSA9PiBhLklEID09PSBib251cy5ib251cy5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heENvdW50ZXIrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZha2VSZWwrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoYm9udXMudGVtcFJlcXVpcmVkID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmIChib251cy50ZW1wUmVxdWlyZWRQZXRzLmZpbmQoKGEpID0+IGEuSUQgPT09IHBldC5JRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBjdXJyQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhDb3VudGVyIDw9IGJvbnVzLmJvbnVzLmFtb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIHRoYXQgd2UgaGF2ZSBzb21lIG9mIHRoZSByZXF1aXJlZCBwZXRzLCBidXQgbm90IGV4Y2VlZGluZyB0aGUgbWF4IGFtb3VudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9udXMudGVtcFJlcXVpcmVkID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYm9udXMuYm9udXMuYW1vdW50IDwgYm9udXMudGVtcFJlcXVpcmVkICYmIG1heENvdW50ZXIgPT09IGJvbnVzLmJvbnVzLmFtb3VudCkgfHwvL21heCBpcyA8IHJlcXVpcmVkIChpLmUuIHdlIGNvdWxkIGZpdCA0IGJ1dCBtYXggaXMgc2V0IHRvIDIpIC0+IGVuc3VyZSAjIHBldHMgPT09IG1heFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXhDb3VudGVyID49IGJvbnVzLnRlbXBSZXF1aXJlZCkgLy9NYXggaXMgPj0gcmVxdWlyZWQsIGVuc3VyZSAjcGV0ID49IHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgd2UgZ29vZGApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHdlIG5vdCBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUZWFtID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9vdGhlcndpc2UsIGVuc3VyZSB3ZSBkb24ndCBleGNlZWQgdGhlIG1heGltdW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRUZWFtID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYm9udXMucGxhY2VtZW50ID09PSBgcmVsYXRpdmVgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9gZXFgIG9yIGBtaW5gIGlzbid0IGFjdGl2ZSwgYnV0IG5lZWRzIHRvIHJlc2VydmUgY2VydGFpbiBwZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9udXMudGVtcE1heCB8fCAoYm9udXMudGVtcE1heCA9PT0gMCAmJiAhYm9udXMuZGlzYWJsZWQgJiYgYm9udXMuZGlzYWJsZWQgIT09IHVuZGVmaW5lZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckNvdW50ID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBldCA9IHByZXZDb21iaW5hdGlvbltqXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib251cy5wZXRzLmZpbmQoKGEpID0+IGEuSUQgPT09IHBldC5JRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJDb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJDb3VudCA8PSBib251cy50ZW1wTWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGB3ZSBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYHdlIG5vdCBnb29kYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVGVhbSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbnVzLnBhc3NlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIChsZXQgeCA9IDA7IHggPCBib251c0xpc3QubGVuZ3RoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB0ZW1wX2lubmVyID0gYm9udXNMaXN0W3hdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYgKHRlbXBfaW5uZXIucGxhY2VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgLy9iaWdzYWQgPSAtMSBub3RlIGRvZXMgbm90IGhhbmRsZSB0aGUgcmVsIGZpbHRlciBmb3IgYm9udXNlcyB2ZXJ5IHdlbGxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZiAodGVtcF9pbm5lci5wYXJhbWV0ZXJzLmZha2UpIHtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBsZXQgcGV0ID0gdGVtcF9pbm5lci5wZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGlmIChwZXQuVHlwZSA9PT0gMSAmJiByZWxHbmRUb3RhbCA+IGduZExpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBlbHNlIGlmIChyZWxBaXJUb3RhbCA+IGFpckxpbWl0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgbWF4UmVsKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0NoZWNrIGlmIHdlIGhhdmUgYWxsIHRoZSByZXEgcGV0cywgYW5kIGVub3VnaCByZWwgcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF4UmVsID4gMCAmJiB2YWxpZFRlYW0pIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1RoZXJlIGFyZSBtb3JlIHJlY29tbWVuZGVkIHRoYW4gd2UgY2FuIGZpdCwgc28ganVzdCBtYWtlIHN1cmUgaGUgaGF2ZSBlbm91Z2hcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXhSZWwgKyBleGFjdCA+IG1heFBldHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZWwgPSBtYXhQZXRzIC0gZXhhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZha2VSZWwgPCBtYXhSZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZFRlYW0gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVGVhbSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRUZWFtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYmlnc2FkID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZFRlYW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpZCA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGlkICsgcHJldkNvbWJpbmF0aW9uW2ldLklEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpICsgMSAhPT0gcHJldkNvbWJpbmF0aW9uLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGlkICsgJywnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHggPSB7IElEOiBpZCwgdGVhbTogcHJldkNvbWJpbmF0aW9uIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0ZW1wLnB1c2goeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0ID0geyBJRDogaWQsIHRlYW06IHByZXZDb21iaW5hdGlvbiwgc2NvcmU6IG1lbW9pemVkR3JvdXBTY29yZSh4KSB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1ciA9IG1lbW9pemVkR3JvdXBTY29yZSh4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5kYW1hZ2UgPT09IGJlc3Quc2NvcmUuZGFtYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXIudG9rZW4gPiBiZXN0LnNjb3JlLnRva2VuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0ID0geyBJRDogaWQsIHRlYW06IHByZXZDb21iaW5hdGlvbiwgc2NvcmU6IGN1ciB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGN1ci5kYW1hZ2UgPiBiZXN0LnNjb3JlLmRhbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0ID0geyBJRDogaWQsIHRlYW06IHByZXZDb21iaW5hdGlvbiwgc2NvcmU6IGN1ciB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocHJldkNvbWJpbmF0aW9uLmxlbmd0aCA9PT0gaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZihpICsgMSwgWy4uLnByZXZDb21iaW5hdGlvbiwgYXJyYXlbaV1dKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZigwLCBbXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoYmVzdC50ZWFtKVxyXG4gICAgICAgICAgICAgICAgYmVzdC50ZWFtLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYS5UeXBlID09PSBiLlR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuSUQgLSBiLklEO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5UeXBlIC0gYi5UeXBlO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGltZTEgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGxldCB0aW1lMiA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgbGV0IHRpbWUzID0gbmV3IERhdGUoKTtcclxuICAgICAgICBsZXQgdGltZTQgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgICAgICBsZXQgYmVzdEdyb3VwcyA9IFtdO1xyXG5cclxuICAgICAgICBsZXQgcGV0c0NvbGxlY3Rpb24gPSBQRVRTQ09MTEVDVElPTi5maWx0ZXIoKGlubmVyX3BldCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaW5uZXJfcGV0LklEIGluIHdoaXRlbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgd2hpdGVsaXN0W2lubmVyX3BldC5JRF0ucGV0ID0gaW5uZXJfcGV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAhKGlubmVyX3BldC5JRCBpbiBibGFja0xpc3QpICYmICEoaW5uZXJfcGV0LklEIGluIHdoaXRlbGlzdClcclxuICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgbnVtR3JvdXBzOyBnKyspIHtcclxuXHJcbiAgICAgICAgICAgIGxldCByZW1haW5pbmdHcm91cHMgPSBudW1Hcm91cHMgLSBnO1xyXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQZXRzT3ZlcmFsbCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRCb251c2VzID0ge307XHJcblxyXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQZXRCb251c01hcCA9IHt9O1xyXG4gICAgICAgICAgICBsZXQgcmVxdWlyZWRQZXRzQnlCb251cyA9IFtdO1xyXG5cclxuICAgICAgICAgICAgbGV0IHdoaXRlTGlzdFJlcVBldHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHdoaXRlbGlzdCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5wYXJhbWV0ZXJzLnRlYW0gPT09IGcpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwZXRzTWFwW3ZhbHVlLnBldC5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB3aGl0ZUxpc3RSZXFQZXRzLnB1c2godmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBldHNDb2xsZWN0aW9uLnB1c2godmFsdWUucGV0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldHNPdmVyYWxsLnB1c2godmFsdWUucGV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGl2ZUJvbnVzZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgLy9OT1RFIGxhdGVyIG5lZWQgdG8gYWRkIGxvZ2ljIHRvIGRldGVybWluZSBpZiBhIGJvbnVzIG1ldCBpdHMgY3JpdGVyaWEgb3Igbm90IGJlZm9yZSBhZGRpbmchISAoaW4gdGhlIGNhc2Ugb2YgZWFybHkgdGVybWluYXRpb24gbGlrZSB0aGVyZXMgb25seSBlbm91Z2ggZm9yIDIgdGVhbXMsIGFuZCBpdHMgZnVsbHkgdXNlZClcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYWN0aXZlQm9udXNlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkQm9udXNlc1thY3RpdmVCb251c2VzW2pdLmlkXSA9IGFjdGl2ZUJvbnVzZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRCb251c01hcFthY3RpdmVCb251c2VzW2pdLmlkXSA9IHsgYm9udXM6IGFjdGl2ZUJvbnVzZXNbal0sIHBldHM6IFtdLCBhY3RpdmU6IHRydWUgfTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHBldHNDb2xsZWN0aW9uLmZvckVhY2goKGN1cnJQZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VyclBldC5JRCBpbiBibGFja0xpc3QpIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyUGV0LkJvbnVzTGlzdC5mb3JFYWNoKChjdXJyQm9udXMpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJCb251cy5JRCBpbiByZXF1aXJlZEJvbnVzZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZEJvbnVzZXNbY3VyckJvbnVzLklEXS5wbGFjZW1lbnQgPT09ICd0b3AnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRzT3ZlcmFsbC5wdXNoKGN1cnJQZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRCb251c01hcFtjdXJyQm9udXMuSURdLnBldHMucHVzaChjdXJyUGV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9DaGVjayB0aGUgYm9udXNlcyBwbGFjZW1lbnQsIGFuZCBpZiBpdCBuZWVkcyB0byBiZSBhZGRlZCAodG9wIGlzIGFsd2F5cyBhY3RpdmUpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFjdGl2ZUJvbnVzZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyckJvbnVzID0gcmVxdWlyZWRQZXRCb251c01hcFthY3RpdmVCb251c2VzW2pdLmlkXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJCb251cy5ib251cy5wbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vTmVlZCB0byBjaGVjayB0aGF0IGl0IGlzIHRpbWUgdG8gcGxhY2UgdGhlc2Ugb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBudW1QZXRzID0gY3VyckJvbnVzLnBldHMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZWRHcm91cHMgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcmVtYWluZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGlzYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG1heCA9IDA7IC8vIGluIGNhc2Ugb2YgbWluIDEvdGVhbSwgIDMgcGV0cyB0b3RhbCBhbW9uZyAzIGdyb3VwcywgbWF4IGlzIDEgLSBjYW4gbm90IGJlIDAgKGlzIGRpc2FibGVkKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGN1cnJCb251cy5ib251cy5lcXVhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWluJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZXJlIGFyZSBub3QgZW5vdWdoIHBldHMgdG8gbWVldCB0aGUgbWluLCB0aGVuIHNldCB0aGUgbWluIHRvICMgb2YgcGV0c1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vdCBlbm91Z2ggcGV0cyBhdCBhbGwsIGRvIG5vdCByZXNlcnZlIGN1cnJlbnQgcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1QZXRzIDwgY3VyckJvbnVzLmJvbnVzLmFtb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1doaWxlIHRoZSBtaW4gaXMgcG9zc2libGUsIHdlIG5lZWQgdG8gY2hlY2sgd2hldGhlciB3ZSBzaG91bGQgc2lsZW50bHkgZW5mb3JjZSBhIG1heCwgdG8gcG9wdWxhdGUgZnV0dXJlIGdyb3Vwc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAocmVtYWluaW5nR3JvdXBzIDw9IHJlcXVpcmVkR3JvdXBzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhUZW1wID0gcmVtYWluaW5nR3JvdXBzICogY3VyckJvbnVzLmJvbnVzLmFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG51bVBldHMgPD0gbWF4VGVtcCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gY3VyckJvbnVzLmJvbnVzLmFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSBudW1QZXRzICUgY3VyckJvbnVzLmJvbnVzLmFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtUGV0cyAtPSByZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkR3JvdXBzID0gbnVtUGV0cyA+PSAwID8gTWF0aC5jZWlsKG51bVBldHMgLyBjdXJyQm9udXMuYm9udXMuYW1vdW50KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdtYXgnOlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VxJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL05vdCBlbm91Z2ggcGV0cyBhdCBhbGwsIGRvIG5vdCByZXNlcnZlIGN1cnJlbnQgcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1QZXRzIDwgY3VyckJvbnVzLmJvbnVzLmFtb3VudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1haW5kZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4VGVtcCA9IHJlbWFpbmluZ0dyb3VwcyAqIGN1cnJCb251cy5ib251cy5hbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1QZXRzIDw9IG1heFRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGN1cnJCb251cy5ib251cy5hbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtYWluZGVyID0gbnVtUGV0cyAlIGN1cnJCb251cy5ib251cy5hbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bVBldHMgLT0gcmVtYWluZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZEdyb3VwcyA9IGN1cnJCb251cy5wZXRzLmxlbmd0aCA+PSBjdXJyQm9udXMuYm9udXMuYW1vdW50ID8gTWF0aC5jZWlsKG51bVBldHMgLyBjdXJyQm9udXMuYm9udXMuYW1vdW50KSA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGltZSB0byBzbG90IGluIHRoZSBwZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZW1haW5pbmdHcm91cHMgPD0gcmVxdWlyZWRHcm91cHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkUGV0Qm9udXNNYXBbY3VyckJvbnVzLmJvbnVzLmlkXS50ZW1wTWF4ID0gbWF4O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckJvbnVzLnBldHMuZm9yRWFjaCgoYm9udXNQZXQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldHNPdmVyYWxsLnB1c2goYm9udXNQZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiBpdCdzIG5vdCB0aW1lIHlldCwgY2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcHV0IGEgbGltaXQgb24gYSBjZXJ0YWluIHN1YnNldCBvZiBwZXRzIGZyb20gYmVpbmcgc2xvdHRlZCBpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmaW5hbEJvbnVzUGV0cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9OZWVkIHRvIGVuc3VyZSB3ZSBkb24ndCByZXNlcnZlIHBldHMgdGhhdCBhcmUgd2hpdGVsaXN0ZWQgdG8gZ28gaW50byBhIGNlcnRhaW4gdGVhbSwgaWYgdGhhdCB0ZWFtIGlzIG5vd1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCByZXF1aXJlZFBldEJvbnVzTWFwW2N1cnJCb251cy5ib251cy5pZF0ucGV0cy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wX2N1cnIgPSByZXF1aXJlZFBldEJvbnVzTWFwW2N1cnJCb251cy5ib251cy5pZF0ucGV0c1t4XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcF9jdXJyLklEIGluIHdoaXRlbGlzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2hpdGVsaXN0W3RlbXBfY3Vyci5JRF0ucGxhY2VtZW50ID09PSBgdGVhbWApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3aGl0ZWxpc3RbdGVtcF9jdXJyLklEXS5wYXJhbWV0ZXJzLnRlYW0gPT09IGcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbEJvbnVzUGV0cy5wdXNoKHRlbXBfY3Vycik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldEJvbnVzTWFwW2N1cnJCb251cy5ib251cy5pZF0ucGV0cyA9IGZpbmFsQm9udXNQZXRzO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldEJvbnVzTWFwW2N1cnJCb251cy5ib251cy5pZF0uYWN0aXZlID0gZmFsc2U7Ly9Pbmx5IHByZXZlbnRzIGVuZm9yY2luZyB0aGUgcmVxdWlyZWQgcGV0cyBwZXQgdGVhbVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRCb251c01hcFtjdXJyQm9udXMuYm9udXMuaWRdLnRlbXBNYXggPSByZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZFBldEJvbnVzTWFwW2N1cnJCb251cy5ib251cy5pZF0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckJvbnVzLmJvbnVzLnBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG51bVBldHMgPSBjdXJyQm9udXMucGV0cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZXF1aXJlZEdyb3VwcyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZW1haW5kZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4ID0gMDsgLy8gaW4gY2FzZSBvZiBtaW4gMS90ZWFtLCAgMyBwZXRzIHRvdGFsIGFtb25nIDMgZ3JvdXBzLCBtYXggaXMgMSAtIGNhbiBub3QgYmUgMCAoaXMgZGlzYWJsZWQpXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWF4VGVtcCA9IHJlbWFpbmluZ0dyb3VwcyAqIGN1cnJCb251cy5ib251cy5hbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudW1QZXRzIDw9IG1heFRlbXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heCA9IGN1cnJCb251cy5ib251cy5hbW91bnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRCb251c01hcFtjdXJyQm9udXMuYm9udXMuaWRdLnRlbXBNYXggPSBtYXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy9DYWxjdWxhdGUgaG93IG1hbnkgcGV0cyBhcmUgYWN0dWFsbHkgc3VwcG9zZWQgdG8gZ28gaW50byB0aGlzIHRlYW0gTk9URSBMQVRFUiBhbHNvIGlmIHRoZXkgc2hvdWxkIGV2ZW4gYmUgYWRkZWQgaW4gdGhlIGZpcnN0IHBsYWNlXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFjdGl2ZUJvbnVzZXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IHJlcXVpcmVkUGV0Qm9udXNNYXBbYWN0aXZlQm9udXNlc1tqXS5pZF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZW1wLmFjdGl2ZSkgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlcXVpcmVkTnVtYmVyID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZXhhY3ROdW1iZXIgPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLmhhcmRGYWlsID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0ZW1wLmJvbnVzLmVxdWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21pbic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZXJlIGFyZSBub3QgZW5vdWdoIHBldHMgdG8gbWVldCB0aGUgbWluLCB0aGVuIHNldCB0aGUgbWluIHRvICMgb2YgcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWlyZWROdW1iZXIgPSB0ZW1wLnBldHMubGVuZ3RoID4gdGVtcC5ib251cy5hbW91bnQgPyB0ZW1wLmJvbnVzLmFtb3VudCA6IHRlbXAucGV0cy5sZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wLmJvbnVzLmFtb3VudCA+IHRlbXAucGV0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGQUlMRUQgZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWROdW1iZXIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAuaGFyZEZhaWwgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkTnVtYmVyID0gdGVtcC5ib251cy5hbW91bnQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ21heCc6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2VxJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YWN0TnVtYmVyID0gdGVtcC5wZXRzLmxlbmd0aCA+IHRlbXAuYm9udXMuYW1vdW50ID8gdGVtcC5ib251cy5hbW91bnQgOiB0ZW1wLnBldHMubGVuZ3RoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcC5ib251cy5hbW91bnQgPiB0ZW1wLnBldHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRkFJTEVEIGZpbHRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0TnVtYmVyID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5oYXJkRmFpbCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3ROdW1iZXIgPSB0ZW1wLmJvbnVzLmFtb3VudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0ZW1wLnJlcXVpcmVkTnVtYmVyID0gcmVxdWlyZWROdW1iZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcC5leGFjdE51bWJlciA9IGV4YWN0TnVtYmVyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL0dldCBhIHN1YnNldCBvZiBwZXRzOiB0aGUgcmVxdWlyZWQgYmFzZWQgb24gYm9udXNlcywgYW55IHRoYXQgaGF2ZSBkbWdCb251cyBvciB0aW1lQm9udXMsIHVwIHRvIDQgbW9yZSBmb3IgbWF4IHJhdyBkdW5nZW9uRGFtYWdlXHJcbiAgICAgICAgICAgIGxldCBmaW5hbFBldHNDb2xsZWN0aW9uID0gdGhpcy5nZXRCZXN0RGFtYWdlUGV0cyhwZXRzQ29sbGVjdGlvbiwgZGVmYXVsdFJhbmssIHsgcmVxdWlyZWRQZXRzOiByZXF1aXJlZFBldHNPdmVyYWxsIH0pO1xyXG5cclxuICAgICAgICAgICAgLy9NYXJrIGV2ZXJ5IHJlcXVpcmVkQm9udXMgYXMgZmFpbGVkICh0byBjaGVjayB3aGF0IHBhc3NlZCBhdCBsZWFzdCBvbmNlKVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhyZXF1aXJlZFBldEJvbnVzTWFwKSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUucGFzc2VkID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHRpbWUxID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgbGV0IGlnbm9yZUN1c3RvbUJvbnVzZXMgPSBmYWxzZTsvL0luIHRoZSBjYXNlIHdoaXRlbGlzdCBpcyBwb3NzaWJsZSwgYnV0IG9ubHkgd2l0aCBjdXN0b21zIGlnbm9yZWRcclxuICAgICAgICAgICAgbGV0IHNraXBDaGVja3MgPSBmYWxzZTsvL0lmIGl0IGZhaWxzIG5vIG1hdHRlciB3aGF0LCBkb24ndCBib3RoZXIgYWRkaW5nIGJvbnVzZXMgaW4gZm9yIHN1YnNlcXVlbnQgYmVzdCB0ZWFtIGdlbmVyYXRpb25cclxuICAgICAgICAgICAgbGV0IGJvbnVzTGlzdCA9IE9iamVjdC52YWx1ZXMocmVxdWlyZWRQZXRCb251c01hcCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2hpdGVMaXN0UmVxUGV0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgYm9udXNMaXN0LnB1c2god2hpdGVMaXN0UmVxUGV0c1tqXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IGNvbWJpbmF0aW9ucyA9IGdldENvbWJpbmF0aW9uc0lubmVyKGZpbmFsUGV0c0NvbGxlY3Rpb24sIE1hdGgubWluKGssIGZpbmFsUGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSwgYm9udXNMaXN0KTtcclxuICAgICAgICAgICAgdGltZTIgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgdGltZSB0byBnZXQgY29tYmluYXRpb25zICR7Y29tYmluYXRpb25zLmxlbmd0aH06ICR7KHRpbWUyIC0gdGltZTEpIC8gMTAwMH0gc2Vjb25kc2ApO1xyXG5cclxuICAgICAgICAgICAgLy9DaGVjayBpZiB3ZSBjYW4gY3JlYXRlIHZhbGlkIHRlYW1zIHdpdGggb25seSB3aGl0ZWxpc3QgcGV0c1xyXG4gICAgICAgICAgICBpZiAoY29tYmluYXRpb25zID09PSAtMSAmJiB3aGl0ZUxpc3RSZXFQZXRzLmxlbmd0aCA+IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBib251c0xpc3QgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2hpdGVMaXN0UmVxUGV0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvbnVzTGlzdC5wdXNoKHdoaXRlTGlzdFJlcVBldHNbal0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25zID0gZ2V0Q29tYmluYXRpb25zSW5uZXIoZmluYWxQZXRzQ29sbGVjdGlvbiwgTWF0aC5taW4oaywgZmluYWxQZXRzQ29sbGVjdGlvbi5sZW5ndGgpLCBib251c0xpc3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9ucyA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hlY2tzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZUN1c3RvbUJvbnVzZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbnMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBza2lwQ2hlY2tzID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGxldCBhbGxQYXNzZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvL0NoZWNrIGlmIGFueSBvZiB0aGUgZmlsdGVycyBmYWlsZWQsIGFuZCBleHBsYWluIHdoaWNoICsgd2h5XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHJlcXVpcmVkUGV0Qm9udXNNYXApKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gZmFpbGVkRmlsdGVyc09iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbHVlLnBhc3NlZCB8fCB2YWx1ZS5oYXJkRmFpbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcE1zZyA9IGBGaWx0ZXIgZmFpbGVkIG9uIGdyb3VwICR7ZyArIDF9OlxcbmA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmJvbnVzLmVxdWF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGBtaW5gOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBNc2cgKz0gYG5vdCBlbm91Z2ggcGV0cywgbWluICR7dmFsdWUuYm9udXMuYW1vdW50fSBidXQgJHt2YWx1ZS5wZXRzLmxlbmd0aH0gcmVtYWluYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgYG1heGA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBgZXFgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBNc2cgKz0gYG5vdCBlbm91Z2ggcGV0cywgcmVxLiAke3ZhbHVlLmJvbnVzLmFtb3VudH0gYnV0ICR7dmFsdWUucGV0cy5sZW5ndGh9IHJlbWFpbmA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW1wb3NzaWJsZSBjYXNlYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkRmlsdGVyc09ialtrZXldID0gdGVtcE1zZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQYXNzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vTWVhbmluZyB0aGVyZSBhcmUganVzdCBubyBwb3NzaWJsZSBjb21iaW5hdGlvbnNcclxuICAgICAgICAgICAgaWYgKHNraXBDaGVja3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKHJlcXVpcmVkUGV0Qm9udXNNYXApLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIShgZ2VuZXJpY2AgaW4gZmFpbGVkRmlsdGVyc09iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFpbGVkRmlsdGVyc09ialtgZ2VuZXJpY2BdID0gYEluZGl2aWR1YWwgZmlsdGVycyBhbGwgc3VjY2VlZGVkLCBidXQgdGhlIGNvbWJpbmF0aW9uIG9mIGFsbCBpcyBpbXBvc3NpYmxlIHN0YXJ0aW5nIGdyb3VwICR7ZyArIDF9YDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL09ubHkgdHJ5IHJlbCwgaWYgaXQncyBwb3NzaWJsZSAobWVhbmluZyBkb24ndCBza2lwIGN1c3RvbSBib251c2VzKVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaWdub3JlQ3VzdG9tQm9udXNlcykge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBiZXN0Q3VyclRlYW1TY29yZSA9IHRoaXMuY2FsY3VsYXRlR3JvdXBTY29yZShjb21iaW5hdGlvbnMudGVhbSwgZGVmYXVsdFJhbmspO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNjb3JlID0gYmVzdEN1cnJUZWFtU2NvcmUuZ3JvdXBTY29yZTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaW5kaXZpZHVhbFJlbCA9IE9iamVjdC52YWx1ZXMod2hpdGVsaXN0UmVsKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlQm9udXNlcy5sZW5ndGggPiAwIHx8IGluZGl2aWR1YWxSZWwubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGRlZCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGluZGl2aWR1YWxSZWwubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1ckJvbnVzID0gaW5kaXZpZHVhbFJlbFtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG11bHQgPSBjdXJCb251cy5wYXJhbWV0ZXJzLmRhbWFnZUJpYXMgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXRPZmYgPSBzY29yZSAqIG11bHQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1MZW5ndGggPSBjb21iaW5hdGlvbnMudGVhbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhbW91bnRUb0FkZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib251c1BldCA9IHBldHNNYXBbY3VyQm9udXMuaWRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZG1nID0gdGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKGJvbnVzUGV0LCBkZWZhdWx0UmFuayk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJvbnVzUGV0KSBjb250aW51ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvbnVzUGV0LkJvbnVzTGlzdC5mb3JFYWNoKChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRBZGRpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0RuZyBkbWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLklEID09PSAxMDEzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1nICo9ICgxICsgdGhpcy5FWFBfRE1HX01PRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtTGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0dldCBhdmcgYmFzZSBncm91cCBzY29yZSwgdGhlbiByZW1vdmUgMSwgYXBwbHkgbXVsdCAoaXBsaWVyKSwgYXBwbHkgbW9kaWZpZXIsIGFkZCBpdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFkZGl0aW9uICs9ICgoYmVzdEN1cnJUZWFtU2NvcmUuYmFzZUdyb3VwU2NvcmUgLyB0bUxlbmd0aCkgKiAodG1MZW5ndGggLSAxKSAqIG11bHQgKiAodGhpcy5FWFBfRE1HX01PRCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtb2RpZmllZEFkZGl0aW9uICs9ICh0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYm9udXNQZXQsIGRlZmF1bHRSYW5rKSAqIDMgKiBtdWx0ICogKHRoaXMuRVhQX0RNR19NT0QpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkQWRkaXRpb24gPSBiZXN0Q3VyclRlYW1TY29yZS5iYXNlR3JvdXBTY29yZSAqIG11bHQgKiAodGhpcy5FWFBfRE1HX01PRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvQWRkICs9IG1vZGlmaWVkQWRkaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlLklEID09PSAxMDEyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1nICo9ICgxICsgdGhpcy5FWFBfVElNRV9NT0QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bUxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9HZXQgYXZnIGJhc2UgZ3JvdXAgc2NvcmUsIHRoZW4gcmVtb3ZlIDEsIGFwcGx5IG11bHQgKGlwbGllciksIGFwcGx5IG1vZGlmaWVyLCBhZGQgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBZGRpdGlvbiArPSAodGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKGJvbnVzUGV0LCBkZWZhdWx0UmFuaykgKiAzICogbXVsdCAqICh0aGlzLkVYUF9USU1FX01PRCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBZGRpdGlvbiA9IGJlc3RDdXJyVGVhbVNjb3JlLmJhc2VHcm91cFNjb3JlICogbXVsdCAqICh0aGlzLkVYUF9USU1FX01PRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvQWRkICs9IG1vZGlmaWVkQWRkaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkbWcgKz0gYW1vdW50VG9BZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG1nID4gY3V0T2ZmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0JvbnVzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjdXJCb251cykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmV3Qm9udXMucGxhY2VtZW50ID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvbnVzLnBsYWNlbWVudCA9ICd0ZWFtJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvbnVzLnBhcmFtZXRlcnMudGVhbSA9IGc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdCb251cy5wZXQgPSBib251c1BldDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0JvbnVzLnBhcmFtZXRlcnMuZmFrZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1NpbmNlIGl0IGlzIGEgc2luZ2xlIHBldCwgYW5kIGl0ICpoYXMqIHRvIGJlIGluc2VydGVkIG5vdywgd2UgY2FuIGhpdGNoaWtlIG9mZiBvZiB0aGUgYnVpbHQgaW4gYHdoaWx0ZUxpc3RSZXFQZXRzYCBzeXN0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaXRlTGlzdFJlcVBldHMucHVzaChuZXdCb251cylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vQWRkIHBldCBpbnRvIGxpc3Qgb2YgcGV0cyB0byBjb21iaW5lLCBpZiBpdCdzIG5vdCBhbHJlYWR5IHRoZXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gZmluYWxQZXRzQ29sbGVjdGlvbi5maW5kKChhKSA9PiBhLklEID09PSBib251c1BldC5JRCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbFBldHNDb2xsZWN0aW9uLnB1c2goYm9udXNQZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhY3RpdmVCb251c2VzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJCb251cyA9IGFjdGl2ZUJvbnVzZXNbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtdWx0ID0gY3VyQm9udXMucmVsVGhyZXNoIC8gMTAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3V0T2ZmID0gc2NvcmUgKiBtdWx0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ZXJCb251cyA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lckFkZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gcmVxdWlyZWRQZXRCb251c01hcFtjdXJCb251cy5pZF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyQm9udXMucGxhY2VtZW50ID09PSAncmVsJykge1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm9udXNQZXRzID0gdGVtcC5wZXRzO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvbnVzUGV0cy5mb3JFYWNoKChib251c1BldCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkbWcgPSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYm9udXNQZXQsIGRlZmF1bHRSYW5rKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdG1MZW5ndGggPSBjb21iaW5hdGlvbnMudGVhbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFtb3VudFRvQWRkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib251c1BldC5Cb251c0xpc3QuZm9yRWFjaCgoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRBZGRpdGlvbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vRG5nIGRtZ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5JRCA9PT0gMTAxMykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1nICo9ICgxICsgdGhpcy5FWFBfRE1HX01PRCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1MZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9HZXQgYXZnIGJhc2UgZ3JvdXAgc2NvcmUsIHRoZW4gcmVtb3ZlIDEsIGFwcGx5IG11bHQgKGlwbGllciksIGFwcGx5IG1vZGlmaWVyLCBhZGQgaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFkZGl0aW9uICs9ICgoYmVzdEN1cnJUZWFtU2NvcmUuYmFzZUdyb3VwU2NvcmUgLyB0bUxlbmd0aCkgKiAodG1MZW5ndGggLSAxKSAqIG11bHQgKiAodGhpcy5FWFBfRE1HX01PRCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vZGlmaWVkQWRkaXRpb24gKz0gKHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShib251c1BldCwgZGVmYXVsdFJhbmspICogMyAqIG11bHQgKiAodGhpcy5FWFBfRE1HX01PRCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBZGRpdGlvbiA9IGJlc3RDdXJyVGVhbVNjb3JlLmJhc2VHcm91cFNjb3JlICogbXVsdCAqICh0aGlzLkVYUF9ETUdfTU9EKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvQWRkICs9IG1vZGlmaWVkQWRkaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5JRCA9PT0gMTAxMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1nICo9ICgxICsgdGhpcy5FWFBfVElNRV9NT0QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtTGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vR2V0IGF2ZyBiYXNlIGdyb3VwIHNjb3JlLCB0aGVuIHJlbW92ZSAxLCBhcHBseSBtdWx0IChpcGxpZXIpLCBhcHBseSBtb2RpZmllciwgYWRkIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRBZGRpdGlvbiArPSAoKGJlc3RDdXJyVGVhbVNjb3JlLmJhc2VHcm91cFNjb3JlIC8gdG1MZW5ndGgpICogKHRtTGVuZ3RoIC0gMSkgKiBtdWx0ICogKHRoaXMuRVhQX1RJTUVfTU9EKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEFkZGl0aW9uID0gYmVzdEN1cnJUZWFtU2NvcmUuYmFzZUdyb3VwU2NvcmUgKiBtdWx0ICogKHRoaXMuRVhQX1RJTUVfTU9EKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtb3VudFRvQWRkICs9IG1vZGlmaWVkQWRkaXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWcgKz0gYW1vdW50VG9BZGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkbWcgPiBjdXRPZmYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckFkZGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnRlbXBNaW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnRlbXBSZXF1aXJlZCA9IHRlbXAudGVtcFJlcXVpcmVkICE9PSAwICYmIHRlbXAudGVtcFJlcXVpcmVkID8gdGVtcC50ZW1wUmVxdWlyZWQgKyAxIDogMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVtcC50ZW1wUmVxdWlyZWRQZXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnRlbXBSZXF1aXJlZFBldHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC50ZW1wUmVxdWlyZWRQZXRzLnB1c2goYm9udXNQZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXhpc3RzID0gZmluYWxQZXRzQ29sbGVjdGlvbi5maW5kKChhKSA9PiBhLklEID09PSBib251c1BldC5JRCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV4aXN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxQZXRzQ29sbGVjdGlvbi5wdXNoKGJvbnVzUGV0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4aXN0cyA9IHJlcXVpcmVkUGV0c092ZXJhbGwuZmluZCgoYSkgPT4gYS5JRCA9PT0gYm9udXNQZXQuSUQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFleGlzdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICByZXF1aXJlZFBldHNPdmVyYWxsLnB1c2goYm9udXNQZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5uZXJBZGRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAudGVtcE1pbiA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcC50ZW1wUmVxdWlyZWQgPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLnRlbXBSZXF1aXJlZFBldHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL0F0IGxlYXN0IDEgcmVsIHBldCB3YXMgYWRkZWQsIHJlY2FsYyB0ZWFtcyB3aXRoIGl0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmFsUGV0c0NvbGxlY3Rpb24gPSB0aGlzLmdldEJlc3REYW1hZ2VQZXRzKHBldHNDb2xsZWN0aW9uLCBkZWZhdWx0UmFuaywgeyByZXF1aXJlZFBldHM6IHJlcXVpcmVkUGV0c092ZXJhbGwgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWUxID0gbmV3IERhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJvbnVzTGlzdCA9IE9iamVjdC52YWx1ZXMocmVxdWlyZWRQZXRCb251c01hcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2hpdGVMaXN0UmVxUGV0cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHdoaXRlTGlzdFJlcVBldHNbal0ucGxhY2VtZW50ID09PSBgcmVsYXRpdmVgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgLy8gZmluYWxQZXRzQ29sbGVjdGlvbi5wdXNoKHdoaXRlTGlzdFJlcVBldHNbal0ucGV0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib251c0xpc3QucHVzaCh3aGl0ZUxpc3RSZXFQZXRzW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29tYmluYXRpb25zX3JlbCA9IGdldENvbWJpbmF0aW9uc0lubmVyKGZpbmFsUGV0c0NvbGxlY3Rpb24sIE1hdGgubWluKGssIGZpbmFsUGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSwgYm9udXNMaXN0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYGdvdCBuZXcgY29tYmluYXRpb25zIGFmdGVyIHRoZSByZWwgY2FsY3NgKVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9uc19yZWwgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL09ubHkgZmlsdGVyIG91dCB0aGUgZmFrZSBgcmVsYCB3aGl0ZWxpc3RlZCBwZXRzLCBpZiB0aGV5IFdFUkUgc2VsZWN0ZWQgYnkgdGhlIGNvbWJvXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGl0ZUxpc3RSZXFQZXRzID0gd2hpdGVMaXN0UmVxUGV0cy5maWx0ZXIoKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGVtcCA9IGNvbWJpbmF0aW9uc19yZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlLnBhcmFtZXRlcnMuZmFrZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IGNvbWJpbmF0aW9uc19yZWwudGVhbS5maW5kKChpbm5lcl9wZXQpID0+IGlubmVyX3BldC5JRCA9PT0gZS5pZClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vT25seSBoYXJkIGNyYXNoIGluIGNhc2Ugb2Ygbm8gYmFja3VwIHRlYW0gdGhhdCBpcyBwb3NzaWJsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tYmluYXRpb25zX3JlbCA9PT0gLTEgJiYgd2hpdGVMaXN0UmVxUGV0cy5sZW5ndGggPT09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShgZ2VuZXJpY2AgaW4gZmFpbGVkRmlsdGVyc09iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRGaWx0ZXJzT2JqW2BnZW5lcmljYF0gPSBgSW5kaXZpZHVhbCBmaWx0ZXJzIGFsbCBzdWNjZWVkZWQsIGJ1dCB0aGUgY29tYmluYXRpb24gb2YgYWxsIGlzIGltcG9zc2libGUgc3RhcnRpbmcgZ3JvdXAgJHtnICsgMX0gKHRvbyBtYW55IHJlbGF0aXZlIHBldHMgaW4gb25lIHRlYW0pYDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbWJpbmF0aW9uc19yZWwgIT09IC0xKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tYmluYXRpb25zID0gY29tYmluYXRpb25zX3JlbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0Fsc28gbmVlZCB0byBkZWxldGUgYWxsIHRoZSByZWwgd2hpdGVsaXN0cyBmcm9tIGZ1dHVyZSB0ZWFtcywgb25seSBpZiB0aGV5IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGJvbnVzTGlzdC5sZW5ndGg7IHgrKykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9udXNMaXN0W3hdLmlkIGluIHdoaXRlbGlzdFJlbCAmJiBjb21iaW5hdGlvbnNfcmVsLnRlYW0uZmluZCgoaW5uZXJfcGV0KSA9PiBpbm5lcl9wZXQuSUQgPT09IGJvbnVzTGlzdFt4XS5pZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHdoaXRlbGlzdFJlbFtib251c0xpc3RbeF0uaWRdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGJlc3RHcm91cHMucHVzaChjb21iaW5hdGlvbnMudGVhbSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9yZW1vdmUgd2hpdGVsaXN0ZWQgcmVsYXRpdmUgXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbWJpbmF0aW9ucy50ZWFtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9ucy50ZWFtW2ldLklEIGluIHdoaXRlbGlzdFJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2hpdGVsaXN0UmVsW2NvbWJpbmF0aW9ucy50ZWFtW2ldLklEXVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBwZXRzQ29sbGVjdGlvbiA9IHBldHNDb2xsZWN0aW9uLmZpbHRlcigocGV0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tYmluYXRpb25zLnRlYW0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbWJpbmF0aW9ucy50ZWFtW2ldLklEID09PSBwZXQuSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vSnVzdCB1c2UgdGhlIGJlc3QgY29tYmluYXRpb24gYWJvdmVcclxuICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgYmVzdEdyb3Vwcy5wdXNoKGNvbWJpbmF0aW9ucy50ZWFtKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3JlbW92ZSB3aGl0ZWxpc3RlZCByZWxhdGl2ZSBcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tYmluYXRpb25zLnRlYW0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tYmluYXRpb25zLnRlYW1baV0uSUQgaW4gd2hpdGVsaXN0UmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB3aGl0ZWxpc3RSZWxbY29tYmluYXRpb25zLnRlYW1baV0uSURdXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvL1JlbW92ZSB0aGUgcGV0c1xyXG4gICAgICAgICAgICAgICAgcGV0c0NvbGxlY3Rpb24gPSBwZXRzQ29sbGVjdGlvbi5maWx0ZXIoKHBldCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbWJpbmF0aW9ucy50ZWFtLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbnMudGVhbVtpXS5JRCA9PT0gcGV0LklEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lNCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coYHRpbWUgdG8gZ2V0IGJlc3QgY29tYm86ICR7KHRpbWU0IC0gdGltZTMpIC8gMTAwMH0gc2Vjb25kc2ApXHJcbiAgICAgICAgaWYgKG90aGVyPy5zZXRGYWlsZWRGaWx0ZXJzKSB7XHJcbiAgICAgICAgICAgIG90aGVyLnNldEZhaWxlZEZpbHRlcnMoZmFpbGVkRmlsdGVyc09iaik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAvLyBSZXNldCBhbnkgYXV0byBwbGFjZW1lbnRzIGJhY2sgdG8gcHJvcGVyIGF1dG8gZm9yIHZpc3VhbCBwdXJwb3Nlc1xyXG4gICAgICAgIC8vIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF1dG9QZXRzKSkge1xyXG4gICAgICAgIC8vICAgICBhdXRvUGV0c1trZXldLnBsYWNlbWVudCA9ICdhdXRvJztcclxuICAgICAgICAvLyB9XHJcblxyXG5cclxuICAgICAgICBsZXQgc3dhcEhhcHBlbmVkID0gdHJ1ZTtcclxuICAgICAgICBsZXQgbnVtU3dhcHMgPSAtMTtcclxuICAgICAgICB3aGlsZSAoc3dhcEhhcHBlbmVkKSB7XHJcbiAgICAgICAgICAgIG51bVN3YXBzKys7XHJcbiAgICAgICAgICAgIHN3YXBIYXBwZW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBsZXQgY29weUdyb3VwcyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYmVzdEdyb3VwcykpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhTd2FwcyA9IDI7XHJcblxyXG4gICAgICAgICAgICAvLyBHbyBvdmVyIGVhY2ggcGV0IGFuZCBidWJibGUgc29ydCBpZiBwb3NzaWJsZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBncm91cF9pbmRleCA9IDA7IGdyb3VwX2luZGV4IDwgY29weUdyb3Vwcy5sZW5ndGg7IGdyb3VwX2luZGV4KyspIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZWFtID0gY29weUdyb3Vwc1tncm91cF9pbmRleF07XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwZXRfaW5kZXggPSAwOyBwZXRfaW5kZXggPCB0ZWFtLmxlbmd0aDsgcGV0X2luZGV4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgcGV0ID0gdGVhbVtwZXRfaW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzd2FwUGV0ID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdyb3VwID0gdGVhbTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgdG9vSGlnaCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0b29Mb3cgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBwZXQgd2FzIHBsYWNlZCBieSBgZ3JvdXBgIGJ5IHVzZXIsIGRvIG5vdCBzaGlmdCFcclxuICAgICAgICAgICAgICAgICAgICBpZiAobG9ja2VkUGV0c1twZXQuSURdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9NaWdodCBub3QgbmVlZCB0aGlzIHNpbmNlIHRoaW5ncyBzdGFydCBsb3cgYW5kIGdvIHVwXHJcbiAgICAgICAgICAgICAgICAgICAgLy9GaXJzdCBjaGVjayBpZiB0aGUgcGV0IHNob3VsZCBiZSBvbiBhIGxvd2VyIHRlYW1cclxuICAgICAgICAgICAgICAgICAgICAvL0RvIHRoaXMgYnkgc2VlaW5nIGlmIGEgc3dhcCBnaXZlcyBhIGhpZ2hlciBkYW1hZ2Ugb24gY3VycmVudCB0ZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyb3VwX2luZGV4IDwgKGJlc3RHcm91cHMubGVuZ3RoIC0gMSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdWJzZXF1ZW50R3JvdXAgPSBjb3B5R3JvdXBzW2dyb3VwX2luZGV4ICsgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0cmllZFBldHMgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRHcm91cFNjb3JlID0gdGhpcy5jYWxjdWxhdGVHcm91cFNjb3JlKGdyb3VwLCBkZWZhdWx0UmFuaykuZ3JvdXBTY29yZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4U3dhcHM7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdWJzZXF1ZW50R3JvdXAubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGV0ID0gc3Vic2VxdWVudEdyb3VwW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdQZXQuVHlwZSA9PT0gcGV0LlR5cGUgJiYgIXRyaWVkUGV0c1tuZXdQZXQuSURdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWVkUGV0c1tuZXdQZXQuSURdID0gbmV3UGV0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0dyb3VwID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0ZWFtKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0dyb3VwW3BldF9pbmRleF0gPSBuZXdQZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3U2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUdyb3VwU2NvcmUobmV3R3JvdXAsIGRlZmF1bHRSYW5rKS5ncm91cFNjb3JlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBiZXR0ZXIgcGV0IGZyb20gbG93ZXIgdGVhbSB0byBncmFiIVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcmUgPiBjdXJyZW50R3JvdXBTY29yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ3NhZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9vSGlnaCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzd2FwSGFwcGVuZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL1NlY29uZCBjaGVjayBpZiB0aGUgcGV0IHNob3VsZCBiZSBvbiBhIGhpZ2hlciB0ZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgLy9EbyB0aGlzIGJ5IHNlZWluZyBpZiBhIHN3YXAgZ2l2ZXMgYSBoaWdoZXIgZGFtYWdlIG9uIHRvIHRoZSBwcmV2aW91cyB0ZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b29IaWdoICYmIGdyb3VwX2luZGV4ID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRDb3VudGVyID0gZ3JvdXBfaW5kZXggLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnRDb3VudGVyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcmV2aW91c0dyb3VwID0gY29weUdyb3Vwc1tjdXJyZW50Q291bnRlcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJpZWRQZXRzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VycmVudEdyb3VwU2NvcmUgPSB0aGlzLmNhbGN1bGF0ZUdyb3VwU2NvcmUocHJldmlvdXNHcm91cCwgZGVmYXVsdFJhbmspLmdyb3VwU2NvcmU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhTd2FwczsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcHJldmlvdXNHcm91cC5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3UGV0ID0gcHJldmlvdXNHcm91cFtqXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2tlZFBldHNbbmV3UGV0LklEXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1BldC5UeXBlID09PSBwZXQuVHlwZSAmJiAhdHJpZWRQZXRzW25ld1BldC5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICghdHJpZWRQZXRzW25ld1BldC5JRF0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWVkUGV0c1tuZXdQZXQuSURdID0gbmV3UGV0O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBuZXdHcm91cCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocHJldmlvdXNHcm91cCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3R3JvdXBbal0gPSBwZXQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld1Njb3JlID0gdGhpcy5jYWxjdWxhdGVHcm91cFNjb3JlKG5ld0dyb3VwLCBkZWZhdWx0UmFuaykuZ3JvdXBTY29yZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBhIGJldHRlciBwZXQgZnJvbSBsb3dlciB0ZWFtIHRvIGdyYWIhXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2NvcmUgPiBjdXJyZW50R3JvdXBTY29yZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb0xvdyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dhcEhhcHBlbmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0R3JvdXBzW2dyb3VwX2luZGV4XVtwZXRfaW5kZXhdID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuZXdQZXQpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0R3JvdXBzW2N1cnJlbnRDb3VudGVyXVtqXSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGV0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGJpZ3NhZCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXBIYXBwZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXBIYXBwZW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dhcEhhcHBlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q291bnRlci0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3dhcEhhcHBlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc3dhcEhhcHBlbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS5sb2coYG51bSBzd2FwczogJHtudW1Td2Fwc31gKTtcclxuXHJcbiAgICAgICAgYmVzdEdyb3Vwcy5mb3JFYWNoKChpbm5lcl9ncm91cCkgPT4ge1xyXG4gICAgICAgICAgICBpbm5lcl9ncm91cC5zb3J0KChhLCBiKSA9PiBhLklEIC0gYi5JRCk7XHJcbiAgICAgICAgICAgIGlubmVyX2dyb3VwLnNvcnQoKGEsIGIpID0+IGEuVHlwZSAtIGIuVHlwZSk7XHJcbiAgICAgICAgfSlcclxuXHJcblxyXG4gICAgICAgIHJldHVybiBiZXN0R3JvdXBzO1xyXG4gICAgfSxcclxuICAgIGNhbGNCZXN0VG9rZW5Hcm91cDogZnVuY3Rpb24gKHBldHNDb2xsZWN0aW9uLCBkZWZhdWx0UmFuaywgbnVtR3JvdXBzLCBvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGsgPSA0OyAvLyBTaXplIG9mIGVhY2ggZ3JvdXBcclxuXHJcbiAgICAgICAgbnVtR3JvdXBzID0gbnVtR3JvdXBzID8gbnVtR3JvdXBzIDogNztcclxuICAgICAgICBsZXQgZGFtYWdlTW9kZSA9IDE7Ly8xID0gbWF4IGRhbWFnZSwgMiA9IG1pblxyXG5cclxuICAgICAgICBjb25zdCBtZW1vID0ge307XHJcblxyXG4gICAgICAgIGNvbnN0IG1lbW9pemVkR3JvdXBTY29yZSA9IChpbm5lckdyb3VwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGlubmVyR3JvdXAuSUQ7XHJcblxyXG4gICAgICAgICAgICBpZiAoIW1lbW9ba2V5XSB8fCBtZW1vW2tleV0pIHtcclxuICAgICAgICAgICAgICAgIGxldCByZXMgPSB0aGlzLmNhbGN1bGF0ZUdyb3VwU2NvcmUoaW5uZXJHcm91cC50ZWFtLCBkZWZhdWx0UmFuayk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3VtID0gcmVzLnRva2VuTXVsdDtcclxuICAgICAgICAgICAgICAgIG1lbW9ba2V5XSA9IHsgdG9rZW46IHN1bSwgZGFtYWdlOiByZXMuZ3JvdXBTY29yZSwgb3RoZXI6IHJlcyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtZW1vW2tleV07XHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBnZXRDb21iaW5hdGlvbnNJbm5lciA9IChhcnJheSwgaywgcmVxdWlyZWRQZXRzT2JqKSA9PiB7XHJcblxyXG4gICAgICAgICAgICAvLyBsZXQgdGVtcCA9IFtdO1xyXG4gICAgICAgICAgICBsZXQgYmVzdCA9IC0xO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGYgPSAoc3RhcnQsIHByZXZDb21iaW5hdGlvbikgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCByZXF1aXJlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgaWdub3JlZCA9IDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVxdWlyZWRQZXRzID0gW107XHJcbiAgICAgICAgICAgICAgICBsZXQgaWdub3JlZFBldHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRQZXRzT2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQgPSByZXF1aXJlZFBldHNPYmoubWluID8gcmVxdWlyZWRQZXRzT2JqLm1pbiA6IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWRQZXRzID0gcmVxdWlyZWRQZXRzT2JqLnBldHMgPyByZXF1aXJlZFBldHNPYmoucGV0cyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWRQZXRzID0gcmVxdWlyZWRQZXRzT2JqLmlnbm9yZWRQZXRzID8gcmVxdWlyZWRQZXRzT2JqLmlnbm9yZWRQZXRzIDogW107XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHJlcXVpcmVkRm91bmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDb21iaW5hdGlvbi5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlkID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2Q29tYmluYXRpb24ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBpZCArIHByZXZDb21iaW5hdGlvbltpXS5JRDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBwcmV2Q29tYmluYXRpb24ubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCA9IGlkICsgJywnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXF1aXJlZCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcmVxdWlyZWRQZXRzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZDb21iaW5hdGlvbltpXS5JRCA9PSByZXF1aXJlZFBldHNbeF0uSUQpIHJlcXVpcmVkRm91bmQrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlZFBldHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBpZ25vcmVkUGV0cy5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcmV2Q29tYmluYXRpb25baV0uSUQgPT0gaWdub3JlZFBldHNbeF0uSUQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWdub3JlZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWlyZWRGb3VuZCA9PT0gcmVxdWlyZWQgJiYgaWdub3JlZCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeCA9IHsgSUQ6IGlkLCB0ZWFtOiBwcmV2Q29tYmluYXRpb24gfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGVtcC5wdXNoKHgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmVzdCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSB7IElEOiBpZCwgdGVhbTogcHJldkNvbWJpbmF0aW9uLCBzY29yZTogbWVtb2l6ZWRHcm91cFNjb3JlKHgpIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gbWVtb2l6ZWRHcm91cFNjb3JlKHgpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vTWF4IGRhbWFnZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhbWFnZU1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmRhbWFnZSA+IGJlc3Quc2NvcmUuZGFtYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSB7IElEOiBpZCwgdGVhbTogcHJldkNvbWJpbmF0aW9uLCBzY29yZTogY3VyIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci50b2tlbiA9PT0gYmVzdC5zY29yZS50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoY3VyLm90aGVyLnRva2VuUmV3YXJkQ291bnQgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5vdGhlci50b2tlblJld2FyZENvdW50ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1ci5kYW1hZ2UgPCBiZXN0LnNjb3JlLmRhbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QgPSB7IElEOiBpZCwgdGVhbTogcHJldkNvbWJpbmF0aW9uLCBzY29yZTogY3VyIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyLmRhbWFnZSA+IGJlc3Quc2NvcmUuZGFtYWdlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVzdCA9IHsgSUQ6IGlkLCB0ZWFtOiBwcmV2Q29tYmluYXRpb24sIHNjb3JlOiBjdXIgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyLnRva2VuID4gYmVzdC5zY29yZS50b2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZXN0ID0geyBJRDogaWQsIHRlYW06IHByZXZDb21iaW5hdGlvbiwgc2NvcmU6IGN1ciB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRlbXBlciA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q29tYmluYXRpb24ubGVuZ3RoID09PSBrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmKGkgKyAxLCBbLi4ucHJldkNvbWJpbmF0aW9uLCBhcnJheVtpXV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBmKDAsIFtdKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChiZXN0LnRlYW0pXHJcbiAgICAgICAgICAgICAgICBiZXN0LnRlYW0uc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhLlR5cGUgPT09IGIuVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5JRCAtIGIuSUQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLlR5cGUgLSBiLlR5cGU7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgdGltZTMgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGxldCB0aW1lNCA9IG5ldyBEYXRlKCk7XHJcblxyXG4gICAgICAgIGxldCBiZXN0R3JvdXBzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBudW1Hcm91cHM7IGcrKykge1xyXG4gICAgICAgICAgICBsZXQgY29tYmluYXRpb25zID0gLTE7XHJcblxyXG4gICAgICAgICAgICBsZXQgbmV3UGV0c0NvbGxlY3Rpb24gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBldHNDb2xsZWN0aW9uKSk7XHJcbiAgICAgICAgICAgIGxldCBudW1Ub2tlbnMgPSAwO1xyXG4gICAgICAgICAgICBsZXQgYXZnVG9rZW5QZXREbWcgPSAwO1xyXG4gICAgICAgICAgICBsZXQgdG9rZW5QZXRzID0gW107XHJcbiAgICAgICAgICAgIGxldCBtYXhEbWdQZXQ7XHJcbiAgICAgICAgICAgIGxldCBhdmdkTWF4RG1nID0gMDtcclxuICAgICAgICAgICAgbGV0IHRrbkFpciA9IDA7XHJcbiAgICAgICAgICAgIGxldCB0a25HbmQgPSAwO1xyXG5cclxuICAgICAgICAgICAgbmV3UGV0c0NvbGxlY3Rpb24uZm9yRWFjaCgocGV0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBwZXQuQm9udXNMaXN0LmZvckVhY2goKGJvbnVzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90b2tlbiBib251c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChib251cy5JRCA9PT0gMTAxNikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblBldHMucHVzaChwZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdmdUb2tlblBldERtZyArPSB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UocGV0LCBkZWZhdWx0UmFuayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVRva2VucysrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGV0LlR5cGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRrbkduZCsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBldC5UeXBlID09PSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0a25BaXIrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBhdmdUb2tlblBldERtZyAvPSBudW1Ub2tlbnM7XHJcblxyXG4gICAgICAgICAgICBuZXdQZXRzQ29sbGVjdGlvbiA9IHRoaXMuZ2V0QmVzdERhbWFnZVBldHMobmV3UGV0c0NvbGxlY3Rpb24sIGRlZmF1bHRSYW5rLCB7IHJlcXVpcmVkUGV0czogdG9rZW5QZXRzIH0pO1xyXG5cclxuICAgICAgICAgICAgbmV3UGV0c0NvbGxlY3Rpb24gPSBuZXdQZXRzQ29sbGVjdGlvbi5zb3J0KChhLCBiKSA9PiB0aGlzLmNhbGN1bGF0ZVBldEJhc2VEYW1hZ2UoYiwgZGVmYXVsdFJhbmspIC0gdGhpcy5jYWxjdWxhdGVQZXRCYXNlRGFtYWdlKGEsIGRlZmF1bHRSYW5rKSk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhdmdkTWF4RG1nICs9IHRoaXMuY2FsY3VsYXRlUGV0QmFzZURhbWFnZShuZXdQZXRzQ29sbGVjdGlvbltpXSwgZGVmYXVsdFJhbmspO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGF2Z2RNYXhEbWcgLz0gMjtcclxuXHJcblxyXG4gICAgICAgICAgICBsZXQgYmVzdERhbWFnZVRlYW0gPSB0aGlzLmNhbGNCZXN0RGFtYWdlR3JvdXAobmV3UGV0c0NvbGxlY3Rpb24sIGRlZmF1bHRSYW5rLCAxKVswXTtcclxuXHJcbiAgICAgICAgICAgIGF2Z2RNYXhEbWcgPSBiZXN0RGFtYWdlVGVhbSA/IHRoaXMuY2FsY3VsYXRlR3JvdXBTY29yZShiZXN0RGFtYWdlVGVhbSwgZGVmYXVsdFJhbmspIDogW107XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgLy9DcmVhdGUgYSB0cmFzaCB0ZWFtIGZpcnN0XHJcbiAgICAgICAgICAgIGlmIChudW1Ub2tlbnMgPj0gNCAmJiB0a25BaXIgPj0gMiAmJiB0a25HbmQgPj0gMikge1xyXG4gICAgICAgICAgICAgICAgLy9Pbmx5IGZvcmNlIDQgaWYgdGhlcmUgYXJlIGVub3VnaCBmb3IgYSBmdWxsIHN5bmVyZ3lcclxuICAgICAgICAgICAgICAgIGRhbWFnZU1vZGUgPSAyOy8vU2V0IGRhbWFnZSBtb2RlIHRvIG1pblxyXG4gICAgICAgICAgICAgICAgY29tYmluYXRpb25zID0gZ2V0Q29tYmluYXRpb25zSW5uZXIobmV3UGV0c0NvbGxlY3Rpb24sIE1hdGgubWluKGssIG5ld1BldHNDb2xsZWN0aW9uLmxlbmd0aCksIHsgcGV0czogdG9rZW5QZXRzLCBtaW46IDQgfSk7XHJcbiAgICAgICAgICAgICAgICBkYW1hZ2VNb2RlID0gMTsvL1NldCBkYW1hZ2UgYmFjayB0byBtYXhcclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9Pbmx5IDEgdG9rZW4gcGV0IGxlZnQsXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG51bVRva2VucyA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy9JZiBpdCdzIHRoZSBsYXN0IHRlYW0sIHNsb3QgaXQgaW4gZm9yY2VmdWxseVxyXG4gICAgICAgICAgICAgICAgaWYgKGcgPT09IG51bUdyb3VwcyAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5hdGlvbnMgPSBnZXRDb21iaW5hdGlvbnNJbm5lcihuZXdQZXRzQ29sbGVjdGlvbiwgTWF0aC5taW4oaywgbmV3UGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwZXRzOiB0b2tlblBldHMsIG1pbjogdG9rZW5QZXRzLmxlbmd0aCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21iaW5hdGlvbnMgPSBnZXRDb21iaW5hdGlvbnNJbm5lcihuZXdQZXRzQ29sbGVjdGlvbiwgTWF0aC5taW4oaywgbmV3UGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobnVtVG9rZW5zID4gMSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gKDEwMCAtIG90aGVyLnRva2VuRGFtYWdlQmlhcykgLyAxMDA7XHJcbiAgICAgICAgICAgICAgICBsZXQgY3V0T2ZmID0gcGVyY2VudCAqIGF2Z2RNYXhEbWcuZ3JvdXBTY29yZTsgLy8lIG9mIGhpZ2hlc3QgYXZhaWxhYmxlIHBldCdzIGJhc2UgZGFtYWdlICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgIGN1dE9mZiAvPSA1Ljc1OyAvLyB1c2VkIGZvciBjb21wYXJpbmcgd2l0aCBmdWxsIHRlYW0gc2NvcmVcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IG1pblBldHMgPSAyO1xyXG4gICAgICAgICAgICAgICAgaWYgKCh0a25BaXIgPiAxICYmIHRrbkduZCA+IDApIHx8ICh0a25HbmQgPiAxICYmIHRrbkFpciA+IDApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluUGV0cyA9IDM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtVG9rZW5Hcm91cHMgPSBNYXRoLmNlaWwobnVtVG9rZW5zIC8gbWluUGV0cyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy9NYXhpbWlzZSB0aGlzIHRlYW0sIHRoaXMgdHVyblxyXG4gICAgICAgICAgICAgICAgaWYgKG51bVRva2VuR3JvdXBzID49IChudW1Hcm91cHMgLSBnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVGhlcmUgYXJlIG5vdCBlbm91Z2ggZ3JvdXBzIGZvciBhbGwgdG9rZW4gcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgobnVtVG9rZW5Hcm91cHMgLSAobnVtR3JvdXBzIC0gZykpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGFtYWdlTW9kZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGFtYWdlTW9kZSA9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0aW9ucyA9IGdldENvbWJpbmF0aW9uc0lubmVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQZXRzQ29sbGVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oaywgbmV3UGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwZXRzOiB0b2tlblBldHMsIG1pbjogbWluUGV0cyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkYW1hZ2VNb2RlID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGF2Z1Rva2VuUGV0RG1nID4gY3V0T2ZmKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCByZW1haW5pbmdHcm91cHMgPSBudW1Hcm91cHMgLSBnO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vVGhlcmUgYXJlIG5vdCBlbm91Z2ggZ3JvdXBzIGZvciBhbGwgdG9rZW4gcGV0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgocmVtYWluaW5nR3JvdXBzIC0gbnVtVG9rZW5Hcm91cHMpID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGFtYWdlTW9kZSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGFtYWdlTW9kZSA9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vTWF4aW1pc2UgdGhpcyB0ZWFtXHJcbiAgICAgICAgICAgICAgICAgICAgY29tYmluYXRpb25zID0gZ2V0Q29tYmluYXRpb25zSW5uZXIobmV3UGV0c0NvbGxlY3Rpb24sIE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBrLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQZXRzQ29sbGVjdGlvbi5sZW5ndGgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHBldHM6IHRva2VuUGV0cywgbWluOiBtaW5QZXRzIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGRhbWFnZU1vZGUgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy9NaW5pbWlzZSB0aGlzIHRlYW0sIGF0IHRoZSBlbmRcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbWJpbmF0aW9ucyA9IGdldENvbWJpbmF0aW9uc0lubmVyKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdQZXRzQ29sbGVjdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oaywgbmV3UGV0c0NvbGxlY3Rpb24ubGVuZ3RoKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGV0czogW10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZ25vcmVkUGV0czogdG9rZW5QZXRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vbm8gdG9rZW4gcGV0c1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbWJpbmF0aW9ucyA9IGdldENvbWJpbmF0aW9uc0lubmVyKG5ld1BldHNDb2xsZWN0aW9uLCBNYXRoLm1pbihrLCBuZXdQZXRzQ29sbGVjdGlvbi5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbnMgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gbWVtb2l6ZWRHcm91cFNjb3JlKGNvbWJpbmF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBiZXN0R3JvdXBzLnB1c2goY29tYmluYXRpb25zLnRlYW0pO1xyXG4gICAgICAgICAgICAgICAgcGV0c0NvbGxlY3Rpb24gPSBwZXRzQ29sbGVjdGlvbi5maWx0ZXIoXHJcbiAgICAgICAgICAgICAgICAgICAgKHBldCkgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tYmluYXRpb25zLnRlYW0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbnMudGVhbVtpXS5JRCA9PT0gcGV0LklEKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWU0ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhgdGltZSB0byBnZXQgYmVzdCBjb21ibzogJHsodGltZTQgLSB0aW1lMykgLyAxMDAwfSBzZWNvbmRzYClcclxuICAgICAgICAvLyBiZXN0R3JvdXBzLnNvcnQoKVxyXG4gICAgICAgIHJldHVybiBiZXN0R3JvdXBzO1xyXG4gICAgfSxcclxuICAgIGZpbmRCZXN0R3JvdXBzOiBmdW5jdGlvbiAocGV0c0NvbGxlY3Rpb24sIGRlZmF1bHRSYW5rLCBncm91cFJhbmtDcml0ZXJhLCBudW1Hcm91cHMsIG90aGVyKSB7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoZ3JvdXBSYW5rQ3JpdGVyYSkge1xyXG4gICAgICAgICAgICBjYXNlIDE6IC8vZGFtYWdlIGZvY3VzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmVzdERhbWFnZUdyb3VwKHBldHNDb2xsZWN0aW9uLCBkZWZhdWx0UmFuaywgbnVtR3JvdXBzLCBvdGhlcik7XHJcbiAgICAgICAgICAgIGNhc2UgMjogLy8gdG9rZW4gZm9jdXNcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGNCZXN0VG9rZW5Hcm91cChwZXRzQ29sbGVjdGlvbiwgZGVmYXVsdFJhbmssIG51bUdyb3Vwcywgb3RoZXIpO1xyXG4gICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxjQmVzdERhbWFnZUdyb3VwKHBldHNDb2xsZWN0aW9uLCBkZWZhdWx0UmFuaywgbnVtR3JvdXBzLCBvdGhlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhbGNFcXVpcEJvbnVzOiBmdW5jdGlvbiAocGV0LCBib251c0lubmVyKSB7XHJcblxyXG4gICAgICAgIGxldCBib251cyA9IDE7XHJcbiAgICAgICAgbGV0IGN1cnIgPSBwZXQ7XHJcbiAgICAgICAgaWYgKGJvbnVzSW5uZXIuSUQgPT09IDIzKSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3Vyci5MZXZlbCA8IDEpIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IHgxID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuTGV2ZWwpO1xyXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCgwLCB4MSAtIDQ1KTtcclxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5wb3coMS4xNSwgeDIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHg0ID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuUmFuayk7XHJcbiAgICAgICAgICAgIGxldCB4NSA9IE1hdGgubWF4KDAsIHg0IC0gNDUpO1xyXG4gICAgICAgICAgICBsZXQgeDYgPSBNYXRoLnBvdygxLjE1LCB4NSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdG90MyA9ICgoMSArICgyNCArIHgzKSAqIDAuMDEpICogKDEgKyB4NiAqIDAuMDEpIC0gMSk7XHJcbiAgICAgICAgICAgIGJvbnVzID0gdG90MztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYm9udXNJbm5lci5JRCA9PT0gMjgpIHtcclxuXHJcblxyXG4gICAgICAgICAgICBpZiAoY3Vyci5MZXZlbCA8IDEpIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IHgxID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuTGV2ZWwpO1xyXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCgwLCB4MSAtIDQ1KTtcclxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5wb3coMS4xNSwgeDIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHg0ID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuUmFuayk7XHJcbiAgICAgICAgICAgIGxldCB4NSA9IE1hdGgubWF4KDAsIHg0IC0gNDUpO1xyXG4gICAgICAgICAgICBsZXQgeDYgPSBNYXRoLnBvdygxLjE1LCB4NSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdG90MyA9ICgoMSArICgyNCArIHgzKSAqIDAuMDAxKSAqICgxICsgeDYgKiAwLjAxKSAtIDEpO1xyXG4gICAgICAgICAgICBib251cyA9IHRvdDM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGJvbnVzSW5uZXIuSUQgPT09IDI5KSB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY3Vyci5MZXZlbCA8IDEpIHJldHVybiAwO1xyXG5cclxuICAgICAgICAgICAgbGV0IHgxID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuTGV2ZWwpO1xyXG4gICAgICAgICAgICBsZXQgeDIgPSBNYXRoLm1heCgwLCB4MSAtIDQ1KTtcclxuICAgICAgICAgICAgbGV0IHgzID0gTWF0aC5wb3coMS4xNSwgeDIpO1xyXG5cclxuICAgICAgICAgICAgbGV0IHg0ID0gZ2VuZXJhbF9oZWxwZXIuY2FsY3VsYXRlTG9nYXJpdGhtKCAxLjEsIGN1cnIuUmFuayk7XHJcbiAgICAgICAgICAgIGxldCB4NSA9IE1hdGgubWF4KDAsIHg0IC0gNDUpO1xyXG4gICAgICAgICAgICBsZXQgeDYgPSBNYXRoLnBvdygxLjE1LCB4NSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgdG90MyA9ICgoMSArICgyNCArIHgzKSAqIDAuMDAyNSkgKiAoMSArIHg2ICogMC4wMSkgLSAxKTtcclxuICAgICAgICAgICAgYm9udXMgPSB0b3QzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib251c0lubmVyLklEID09PSAzNCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnIuTGV2ZWwgPCAxKSByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgIGxldCB4MSA9IGdlbmVyYWxfaGVscGVyLmNhbGN1bGF0ZUxvZ2FyaXRobSggMS4xLCBjdXJyLkxldmVsKTtcclxuICAgICAgICAgICAgbGV0IHgyID0gTWF0aC5tYXgoMCwgeDEgLSA0NSk7XHJcbiAgICAgICAgICAgIGxldCB4MyA9IE1hdGgucG93KDEuMTI1LCB4Mik7XHJcblxyXG4gICAgICAgICAgICBsZXQgeDQgPSBnZW5lcmFsX2hlbHBlci5jYWxjdWxhdGVMb2dhcml0aG0oIDEuMSwgY3Vyci5SYW5rKTtcclxuICAgICAgICAgICAgbGV0IHg1ID0gTWF0aC5tYXgoMCwgeDQgLSA0NSk7XHJcbiAgICAgICAgICAgIGxldCB4NiA9IE1hdGgucG93KDEuMTUsIHg1KTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0b3QzID0gKCgxICsgKDkgKyB4MykgKiAwLjAwMDI1KSAqICgxICsgeDYgKiAwLjAwMSkgLSAxKTtcclxuICAgICAgICAgICAgYm9udXMgPSB0b3QzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChib251c0lubmVyLklEID09PSAzNSkge1xyXG5cclxuICAgICAgICAgICAgaWYgKGN1cnIuTGV2ZWwgPCAxKSByZXR1cm4gMDtcclxuXHJcbiAgICAgICAgICAgIGxldCB4MSA9IGdlbmVyYWxfaGVscGVyLmNhbGN1bGF0ZUxvZ2FyaXRobSggMS4xLCBjdXJyLkxldmVsKTtcclxuICAgICAgICAgICAgbGV0IHgyID0gTWF0aC5tYXgoMCwgeDEgLSA0NSk7XHJcbiAgICAgICAgICAgIGxldCB4MyA9IE1hdGgucG93KDEuMTI1LCB4Mik7XHJcblxyXG4gICAgICAgICAgICBsZXQgeDQgPSBnZW5lcmFsX2hlbHBlci5jYWxjdWxhdGVMb2dhcml0aG0oIDEuMSwgY3Vyci5SYW5rKTtcclxuICAgICAgICAgICAgbGV0IHg1ID0gTWF0aC5tYXgoMCwgeDQgLSA0NSk7XHJcbiAgICAgICAgICAgIGxldCB4NiA9IE1hdGgucG93KDEuMTUsIHg1KTtcclxuXHJcbiAgICAgICAgICAgIGxldCB0b3QzID0gKCgxICsgKDkgKyB4MykgKiA1RS0wNSkgKiAoMSArIHg2ICogMC4wMDEpIC0gMSk7XHJcbiAgICAgICAgICAgIGJvbnVzID0gdG90MztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7Ly9zXHJcbiAgICAgICAgICAgIGxldCB4MSA9IE1hdGgucG93KDEuMCArIGJvbnVzSW5uZXIuR2FpbiwgY3Vyci5MZXZlbCkgLSAxLjA7XHJcbiAgICAgICAgICAgIGxldCB4MiA9IDEgKyBjdXJyLlJhbmsgKiAwLjAyO1xyXG4gICAgICAgICAgICBib251cyA9IHgxICogeDI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYm9udXMgKiAxMDA7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGRlZmF1bHQgaGVscGVyOyJdLCJuYW1lcyI6WyJnZW5lcmFsX2hlbHBlciIsImhlbHBlciIsIkVYUF9ETUdfTU9EIiwiRVhQX1RJTUVfTU9EIiwiU1lORVJHWV9NT0RfU1RFUCIsIkVYUF9UT0tFTl9NT0QiLCJTT1VMX0NMT1ZFUl9TVEVQIiwiY2FsY3VsYXRlUGV0QmFzZURhbWFnZSIsInBldCIsImRlZmF1bHRSYW5rIiwicmFua0NvdW50IiwiUmFuayIsInJlc3VsdCIsIkJhc2VEdW5nZW9uRGFtYWdlIiwiTnVtYmVyIiwiY2FsY3VsYXRlQmVzdEhvdXJzIiwiZ3JvdXAiLCJob3VycyIsInRva2VuTW9kaWZpZXJzIiwiY29tYm8iLCJjbG92ZXIiLCJyZXNpZHVlVG9rZW4iLCJwZF90b2tlbl9ib251cyIsImRhdGEiLCJFeHBlZGl0aW9uVG9rZW5Cb251c2VzIiwiRXhwZWRpdGlvblJlc291cmNlQm9udXNlcyIsIm92ZXJhbGwiLCJjYWxjdWxhdGVHcm91cFNjb3JlIiwidG9rZW5IUiIsInRva2VuTXVsdCIsImJlc3QiLCJ0b3RhbFRva2VucyIsImZsb29yZWQiLCJlZmZlY2llbmN5IiwiYmVzdEFyciIsImkiLCJsZW5ndGgiLCJoIiwiTWF0aCIsImZsb29yIiwid2FzdGVkIiwid2FzdGVkSFIiLCJ0ZW1wIiwicHVzaCIsImdyb3VwU2NvcmUiLCJkbWdDb3VudCIsInRpbWVDb3VudCIsInN5bmVyZ3lCb251cyIsImJhc2VHcm91cFNjb3JlIiwiY2FyZFBvd2VyQ291bnQiLCJleHBSZXdhcmRDb3VudCIsInJwUmV3YXJkQ291bnQiLCJjYXJkWHBDb3VudCIsInRva2VuUmV3YXJkQ291bnQiLCJ0b2tlbk1vZGlmIiwidHlwZUNvdW50cyIsImdyb3VwU2NvcmVNYXgiLCJmb3JFYWNoIiwiQm9udXNMaXN0Iiwic29tZSIsImJvbnVzIiwiSUQiLCJUeXBlIiwiZWFydGhUeXBlIiwiYWlyVHlwZSIsIk9iamVjdCIsInZhbHVlcyIsImdldEJlc3REYW1hZ2VQZXRzIiwicGV0c0NvbGxlY3Rpb24iLCJvdGhlciIsImZpbmFsQ29sbGVjdGlvbiIsImJlc3REYW1hZ2VQZXRzIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwic3Ryb25nZXN0R25kIiwic3Ryb25nZXN0QWlyIiwidXBkYXRlU3Ryb25nZXN0IiwiZG1nT25seVBldHMiLCJyZXF1aXJlZFBldHMiLCJhaXJEbWdPbmx5Q291bnQiLCJnbmREbWdPbmx5Q291bnQiLCJjdXIiLCJhZGRlZCIsImoiLCJzcGVjaWFsQWlyIiwic3BlY2lhbEduZCIsInNwZWNpYWxQZXRzIiwiY29uY2F0IiwiZXh0cmFHbmQiLCJleHRyYUFpciIsInNvcnRHbmQiLCJzb3J0QWlyIiwiZG1nIiwiaW5uZXJQZXQiLCJpbm5lckRtZyIsInNvcnQiLCJhIiwiYiIsImZpbmFsUGV0c0NvbGxlY3Rpb24iLCJjYWxjQmVzdERhbWFnZUdyb3VwIiwiUEVUU0NPTExFQ1RJT04iLCJudW1Hcm91cHMiLCJrIiwibWVtbyIsImZhaWxlZEZpbHRlcnNPYmoiLCJwZXRzTWFwIiwiYWN0aXZlQm9udXNlcyIsIm1lbW9pemVkR3JvdXBTY29yZSIsImtleSIsInJlcyIsInRlYW0iLCJzdW0iLCJ0b2tlbiIsImRhbWFnZSIsImJsYWNrTGlzdCIsIndoaXRlbGlzdCIsIndoaXRlbGlzdFJlbCIsImxvY2tlZFBldHMiLCJhdXRvUGV0cyIsInBzdWVkb0dyb3VwcyIsInBldFdoaXRlTGlzdCIsInBsYWNlbWVudCIsImlkIiwicGFyYW1ldGVycyIsImJpZ3NhZCIsIm51bUduZCIsIm51bUFpciIsImlubmVyX3BldCIsImF1dG8iLCJnZXRDb21iaW5hdGlvbnNJbm5lciIsImFycmF5IiwiYm9udXNMaXN0IiwiYWlyVGVtcCIsImdyb3VuZFRlbXAiLCJpdGVtIiwiYmFkX3N5bmVyZ3lfYWxsb3dlZCIsInJlcXVpcmVkQWlyIiwicmVxdWlyZWRHbmQiLCJyZWxBaXJUb3RhbE1hcCIsInJlbEduZFRvdGFsTWFwIiwiZmFrZSIsImYiLCJzdGFydCIsInByZXZDb21iaW5hdGlvbiIsInZhbGlkVGVhbSIsImZha2VSZWwiLCJleGFjdCIsIm1heFBldHMiLCJjdXJyQWlyIiwiY3VyckduZCIsInRvdGFsR25kIiwidG90YWxBaXIiLCJ0ZW1weSIsInJlcUFpciIsImVudHJpZXMiLCJyZXFHbmQiLCJyZWxBaXJUb3RhbCIsInJlbEduZFRvdGFsIiwiYWlyTGltaXQiLCJnbmRMaW1pdCIsIm1heFJlbCIsImNoZWNrTnVtIiwiYWlyTWF4SW5jcmVhc2UiLCJnbmRNYXhJbmNyZWFzZSIsInBhc3MiLCJjdXJyQ291bnQiLCJyZXF1aXJlZE51bWJlciIsImZpbmQiLCJleGFjdE51bWJlciIsIm1heENvdW50ZXIiLCJhbW91bnQiLCJ0ZW1wUmVxdWlyZWQiLCJ0ZW1wTWF4IiwiZGlzYWJsZWQiLCJ1bmRlZmluZWQiLCJwZXRzIiwicGFzc2VkIiwieCIsInNjb3JlIiwidGltZTEiLCJEYXRlIiwidGltZTIiLCJ0aW1lMyIsInRpbWU0IiwiYmVzdEdyb3VwcyIsImZpbHRlciIsImciLCJyZW1haW5pbmdHcm91cHMiLCJyZXF1aXJlZFBldHNPdmVyYWxsIiwicmVxdWlyZWRCb251c2VzIiwicmVxdWlyZWRQZXRCb251c01hcCIsInJlcXVpcmVkUGV0c0J5Qm9udXMiLCJ3aGl0ZUxpc3RSZXFQZXRzIiwidmFsdWUiLCJhY3RpdmUiLCJjdXJyUGV0IiwiY3VyckJvbnVzIiwibnVtUGV0cyIsInJlcXVpcmVkR3JvdXBzIiwicmVtYWluZGVyIiwibWF4IiwiZXF1YXRpb24iLCJtYXhUZW1wIiwiY2VpbCIsImJvbnVzUGV0IiwiZmluYWxCb251c1BldHMiLCJ0ZW1wX2N1cnIiLCJoYXJkRmFpbCIsImlnbm9yZUN1c3RvbUJvbnVzZXMiLCJza2lwQ2hlY2tzIiwiY29tYmluYXRpb25zIiwibWluIiwiY29uc29sZSIsImxvZyIsImFsbFBhc3NlZCIsInRlbXBNc2ciLCJFcnJvciIsImJlc3RDdXJyVGVhbVNjb3JlIiwiaW5kaXZpZHVhbFJlbCIsImN1ckJvbnVzIiwibXVsdCIsImRhbWFnZUJpYXMiLCJjdXRPZmYiLCJ0bUxlbmd0aCIsImFtb3VudFRvQWRkIiwiZSIsIm1vZGlmaWVkQWRkaXRpb24iLCJuZXdCb251cyIsImV4aXN0cyIsInJlbFRocmVzaCIsImNvdW50ZXJCb251cyIsImlubmVyQWRkZWQiLCJib251c1BldHMiLCJ0ZW1wTWluIiwidGVtcFJlcXVpcmVkUGV0cyIsImNvbWJpbmF0aW9uc19yZWwiLCJmb3VuZCIsInNldEZhaWxlZEZpbHRlcnMiLCJzd2FwSGFwcGVuZWQiLCJudW1Td2FwcyIsImNvcHlHcm91cHMiLCJtYXhTd2FwcyIsImdyb3VwX2luZGV4IiwicGV0X2luZGV4Iiwic3dhcFBldCIsInRvb0hpZ2giLCJ0b29Mb3ciLCJzdWJzZXF1ZW50R3JvdXAiLCJ0cmllZFBldHMiLCJjdXJyZW50R3JvdXBTY29yZSIsIm5ld1BldCIsIm5ld0dyb3VwIiwibmV3U2NvcmUiLCJjdXJyZW50Q291bnRlciIsInByZXZpb3VzR3JvdXAiLCJpbm5lcl9ncm91cCIsImNhbGNCZXN0VG9rZW5Hcm91cCIsImRhbWFnZU1vZGUiLCJpbm5lckdyb3VwIiwicmVxdWlyZWRQZXRzT2JqIiwicmVxdWlyZWQiLCJpZ25vcmVkIiwiaWdub3JlZFBldHMiLCJyZXF1aXJlZEZvdW5kIiwidGVtcGVyIiwibmV3UGV0c0NvbGxlY3Rpb24iLCJudW1Ub2tlbnMiLCJhdmdUb2tlblBldERtZyIsInRva2VuUGV0cyIsIm1heERtZ1BldCIsImF2Z2RNYXhEbWciLCJ0a25BaXIiLCJ0a25HbmQiLCJiZXN0RGFtYWdlVGVhbSIsInBlcmNlbnQiLCJ0b2tlbkRhbWFnZUJpYXMiLCJtaW5QZXRzIiwibnVtVG9rZW5Hcm91cHMiLCJmaW5kQmVzdEdyb3VwcyIsImdyb3VwUmFua0NyaXRlcmEiLCJjYWxjRXF1aXBCb251cyIsImJvbnVzSW5uZXIiLCJjdXJyIiwiTGV2ZWwiLCJ4MSIsImNhbGN1bGF0ZUxvZ2FyaXRobSIsIngyIiwieDMiLCJwb3ciLCJ4NCIsIng1IiwieDYiLCJ0b3QzIiwiR2FpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/util/petHelper.js\n"));

/***/ })

});